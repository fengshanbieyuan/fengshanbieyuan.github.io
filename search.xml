<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HikariCP源码分析之ConcurrentBag二</title>
      <link href="/2020/07/31/HikariCP-source-code-9/"/>
      <url>/2020/07/31/HikariCP-source-code-9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h4 id="②检查本地保存的连接"><a href="#②检查本地保存的连接" class="headerlink" title="②检查本地保存的连接"></a>②检查本地保存的连接</h4><pre><code class="java">//②//如果ThreadLocal中有连接的话, 就遍历, 尝试获取//从后往前反向遍历是有好处的, 因为最后一次使用的连接, 空闲的可能性比较大, 之前的连接可能会被其他线程偷窃走了for (int i = list.size() - 1; i &gt;= 0; i--) {  final Object entry = list.remove(i);  @SuppressWarnings(&quot;unchecked&quot;) final T bagEntry = weakThreadLocals ? ((WeakReference&lt;T&gt;) entry).get() : (T) entry;  if (bagEntry != null &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {     return bagEntry;  }}</code></pre><p>OK，我们继续。这里遍历的 list 变量，是<code>threadList</code>，是当前线程使用过的连接，保存在本地线程的引用。</p><p>可以看到这个遍历的顺序，是倒序遍历的。list 里的连接，肯定是最后一个是最后放进去的，也就是最近使用过的，这个连接还可以继续使用的可能极大，时间越早的连接，就越可能被其他线程借用走了，所以这就是为什么要倒序遍历，我们要先检查能使用的可能性最大的连接。说到这里，我们在平时的业务代码中，要用 if 检查一些条件，这时候我们要有意识的先检查可能性最大的条件，这有利于减少判断的次数，提高程序的性能。</p><p>在从 list 中获取连接的时候，使用的是<code>remove</code>方法，也就是说，无论如何，这个连接的引用我们不在本地保存了，如果它可以用，那么用完之后它又会加入到本地的<code>threadList</code>，如果不能使用了，那么我们就删除了这个无用的连接引用。</p><pre><code>    下面第 三句代码其实就是类型的强转，忽略之。有意思的是接下来第四句的判断，直接在 if 中就执行修改连接状态的操作。每个连接都有一个状态，它的类型是`AtomicInteger`，是个数字，并且是原子操作，线程安全。`compareAndSet`方法执行的时候，将`STATE_NOT_IN_USE`状态跟连接的当前状态对比，一样的时候才将它修改成`STATE_IN_USE`，既保证了线程安全，又保证了只有在连接是空闲状态才能使用线程，不会错误使用了其他状态的连接。此时，如果状态修改成功了，那么直接将该连接返回给用户使用。    说到这里，应该说一下连接有哪些状态。</code></pre><h5 id="连接的状态"><a href="#连接的状态" class="headerlink" title="连接的状态"></a>连接的状态</h5><ul><li><p>STATE_NOT_IN_USE = 0     //空闲状态, 可以被借走</p></li><li><p>STATE_IN_USE = 1              //使用中状态, 已经被借走, 正在使用中 </p></li><li><p>STATE_REMOVED = -1       //已删除状态, 不能借走</p></li><li><p>STATE_RESERVED = -2       //保留状态, 不能借走</p></li></ul><p>一共四种状态，只有在连接空闲的时候才能被借走，其他三个状态都不行。值得一提的是<code>STATE_RESERVED</code>状态，它是在连接池挂起时的一个状态，如果不知道连接池挂起，大家可以看下《HikariCP源码分析之获取连接流程二》。</p><h4 id="③准备工作"><a href="#③准备工作" class="headerlink" title="③准备工作"></a>③准备工作</h4><pre><code class="java">//③//如果没有从ThreadLocal中获取到连接, 那么就sharedList连接池中遍历, 获取连接, timeout时间后超时//因为ThreadLocal中保存的连接是当前线程使用过的, 才会在ThreadLocal中保留引用, 连接池中可能还有其他空闲的连接, 所以要遍历连接池//看一下requite(final T bagEntry)方法的实现, 还回去的连接放到了ThreadLocal中timeout = timeUnit.toNanos(timeout);Future&lt;Boolean&gt; addItemFuture = null;//记录从连接池获取连接的开始时间, 后面用final long startScan = System.nanoTime();final long originTimeout = timeout;long startSeq;//将等待连接的线程计数器加 1waiters.incrementAndGet();</code></pre><p>上面说到了从本地的<code>threadList</code>中获取连接，如果拿不到的话，那么就要走到这里了。这里是获取连接前的准备工作。</p><ul><li><p><code>timeout</code>是获取连接的超时时间，这个是作为参数传入的，转换为纳秒可以提高精度。</p></li><li><p><code>startScan</code>是记录开始获取连接的起始时间，用于后面计算还剩下多少时间的。</p></li><li><p><code>originTimeout</code>就等于<code>timeout</code>，因为<code>timeout</code>代表剩余时间，后面的计算中会变的，所以赋值给<code>originTimeout</code>，记住原始的值是多少。</p></li><li><p><code>startSeq</code>用于记录当期synchronizer的值，它是判断是否有新连接加入连接池的。每当有一个新连接加入，synchronizer就会加 1，我们只要记下synchronizer的当前值，然后一段时间后比较synchronizer最新值，如果synchronizer变大了，就说明有新连接加入了。</p></li><li><p><code>waiters</code>是等待中的线程数，是记录有多少线程在等待获取连接的计数器。此处将计数器加 1。</p></li></ul><p>其实上面代码都是一些用于记录原始值的，没什么好说的。</p><p>我们稍微说说<code>System.nanoTime()</code>吧，跟<code>System.currentTimeMillis()</code>非常像的方法，都是获取时间的。但是<code>System.currentTimeMillis()</code>获取的是系统时间的毫秒数，而<code>System.nanoTime()</code>获取的并不是系统时间的纳秒数，这个很多同学可能一直误会了这个方法。</p><pre><code>    JDK 提供的`System.currentTimeMillis()`方法其实获取的时间并不准确，因为可能会受到时间校准的影响，而`System.nanoTime()`返回当前JVM的高精度时间，该方法只能用来测量时段而和系统时间无关，它的返回值可能是从某个时间点开始计算的，可能是负数，只能用于计算时间差，不能用于系统时间相关的逻辑。    所以，在做性能测试的时候，统计时间，使用`System.nanoTime()`比较好。Netty 中的时间轮就是使用这个，调系统时间不会导致触发任务。</code></pre><h4 id="④⑤添加连接任务"><a href="#④⑤添加连接任务" class="headerlink" title="④⑤添加连接任务"></a>④⑤添加连接任务</h4><pre><code class="java">do {//④//当前连接池中的连接数, 在连接池中添加新连接的时候, 该值会增加startSeq = synchronizer.currentSequence();for (T bagEntry : sharedList) {   if (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {      // if we might have stolen another thread&#39;s new connection, restart the add...      //⑤      //如果waiters大于 1, 说明除了当前线程之外, 还有其他线程在等待空闲连接      //这里, 当前线程的addItemFuture是 null, 说明自己没有请求创建新连接, 但是拿到了连接, 这就说明是拿到了其他线程请求创建的连接, 这就是所谓的偷窃了其他线程的连接, 然后当前线程请求创建一个新连接, 补偿给其他线程      if (waiters.get() &gt; 1 &amp;&amp; addItemFuture == null) {         //提交一个异步添加新连接的任务         listener.addBagItem();      }      return bagEntry;   }}} while (startSeq &lt; synchronizer.currentSequence()); //如果连接池中的空闲连接数量比循环之前多了, 说明有新连接加入, 继续循环获取</code></pre><p>④和⑤我们还是一起分析比较好。上面我们已经说过了<code>startSeq</code>，略。</p><p><code>sharedList</code>是整个 HikariCP 的连接池，里面保存了所有的连接，终于，在这里进入主题了。</p><p>我们遍历整个连接池，尝试获取连接，在if 的<code>compareAndSet</code>中一个一个尝试修改它的状态，如果修改成功了，说明我们拿到了这个连接的使用权，Good！本来应该直接 return这个连接给用户就可以了吧？为什么还要判断？？？</p><pre><code>    在上面一篇文章中，我们举例租车的时候，提到过，线程间的连接是会相互窃取的，其实那个窃取不算是真的窃取，因为虽然你本地保存了连接的引用，但是连接又不是你创建的，其他线程也可以从连接池里拿，没有毛病。    但是这里是真的窃取。我们判断`waiters.get() &gt; 1 &amp;&amp; addItemFuture == null`，`waiters`是当前正在等待获取连接的线程数，这个我们说过了。它大于 1，说明除了当前线程自己在等之外，还有别的线程也在等连接呢；`addItemFuture`代表创建连接的任务，它是 null 的话，说明当前线程自己没有创建过创建新连接的任务。但是呢，我居然拿到连接了，你说运气好不好！巧了呀！既然这个连接不是我们创建的，那肯定是别的线程创建的呀，我们偷来了，这咋整呢，要不我们补偿一个给它吧。于是，我们执行`listener.addBagItem();`请求创建一个新连接补偿给别的线程，别让人一直等了！   如果 for 循环执行完了，还是没有拿到连接呢？这个 for 循环是 do-while 循环中嵌套的 for 循环，for 循环执行完了一遍，就说明整个连接池我们查找了一遍，没有拿到连接。那么do-while要不要继续执行，要看条件了对吧？    `startSeq &lt; synchronizer.currentSequence()`，`startSeq`是我们循环之前记录的连接数量，`synchronizer.currentSequence()`是当前的连接数量，如果现在比之前的数量大了，说明有新连接加入了连接池，就可以继续执行 for 循环遍历连接池。    如果`startSeq &lt; synchronizer.currentSequence()`不成立，说明我们在执行 for 循环期间，没有新连接加入连接池。</code></pre><h4 id="⑥请求创建连接"><a href="#⑥请求创建连接" class="headerlink" title="⑥请求创建连接"></a>⑥请求创建连接</h4><pre><code class="javaag-0-1eeig14joag-1-1eeig14jo">//⑥//循环完一遍连接池(也可能循环多次, 如果正好在第一次循环完连接池后有新连接加入, 那么会继续循环), 还是没有能拿到空闲连接, 就请求创建新的连接if (addItemFuture == null || addItemFuture.isDone()) {addItemFuture = listener.addBagItem();}//计算 剩余的超时时间 = 用户设置的connectionTimeout - (系统当前时间 - 开始获取连接的时间_代码①处 即从连接池中获取连接一共使用的时间)timeout = originTimeout - (System.nanoTime() - startScan);} while (timeout &gt; 10_000L &amp;&amp; synchronizer.waitUntilSequenceExceeded(startSeq, timeout)); //③</code></pre><p>上面的代码是不完整的，少了一个 do，在最外层，不影响我们分析。此处的循环是一个三层的嵌套，两个 do-while，里面再嵌套一个 for 循环，很绕。</p><pre><code>    上面我们说到了，遍历完整个连接池之后，也没有新连接加入连接池，for 循环和里层的 do-while 就执行完了。此时是真的没有连接可用了，怎么办，创建一个连接呗，然后执行如下的 if判断`addItemFuture == null || addItemFuture.isDone()`，`addItemFuture == null`说明没有创建过创建连接的任务，那么`addItemFuture.isDone()`是啥？这是说明它创建过创建连接的任务，任务执行完了，悲催的是，我们还是没有拿到创建的连接，肯定是让哪个天杀的线程偷了，没有天理了呀！没办法，我们执行`addItemFuture = listener.addBagItem();`再创建一个连接。    此时，还有最外层的一个 do-while 循环，它的判断条件是什么？我们好像还一直没有检查超时时间吧？没错，就是这个了。`timeout = originTimeout - (System.nanoTime() - startScan);`计算一下，我们获取连接还剩余多少时间了。</code></pre><p><code>timeout &gt; 10_000L &amp;&amp; synchronizer.waitUntilSequenceExceeded(startSeq, timeout)</code>这个条件有点小复杂。</p><ul><li><p><code>timeout &gt; 10_000L</code>表示剩余时间至少要大于10000纳秒，太少了说不定还没有执行一次 for 循环就到时间了。</p></li><li><p><code>synchronizer.waitUntilSequenceExceeded(startSeq, timeout)</code>这个条件比较神奇，如果在<code>timeout</code>时间内，<code>synchronizer</code>的值大于<code>startSeq</code>，就返回 true。</p></li></ul><p>综合一下，最外层的 do-while 要执行的话，必须剩余超时时间<code>timeout</code>大于 10000 纳秒，同时，在<code>timeout</code>时间用尽之前，必须有新连接加入连接池，我们才能继续执行循环，否则一直阻塞，直到条件达成或者时间用尽。</p><h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p>代码还剩一个 finally 了。</p><pre><code class="java">} finally {      waiters.decrementAndGet();   }   return null;</code></pre><p>borrow 方法的最后几行代码，直到线程前面用尽最后的时间，也没有获取到连接，最后，不能再等了，从等待线程的计数器中把自己减去，直接返回 null 给用户吧，尽力了……</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP源码解析系列目录</title>
      <link href="/2020/07/30/HikariCP-source-code-0/"/>
      <url>/2020/07/30/HikariCP-source-code-0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h3 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h3><p>推荐大家按照以下顺序阅读：</p><ul><li><p><a href="https://www.fsby.fun/2020/07/04/HikariCP-source-code-1/" target="_blank" rel="noopener">HikariCP获取连接流程源码分析一 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/05/HikariCP-source-code-2/" target="_blank" rel="noopener">HikariCP获取连接流程源码分析二 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/06/HikariCP-source-code-3/" target="_blank" rel="noopener">HikariCP获取连接流程源码分析三 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/05/HikariCP-source-code-4/" target="_blank" rel="noopener">HikariCP源码分析之初始化分析一 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/05/HikariCP-source-code-5/" target="_blank" rel="noopener">HikariCP源码分析之初始化分析二 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/12/HikariCP-source-code-6/" target="_blank" rel="noopener">HikariConfig的配置解析 | 枫山别院</a></p></li><li><p><a href="https://www.fsby.fun/2020/07/12/HikariCP-source-code-7/" target="_blank" rel="noopener">HikariConfig初始化分析 | 枫山别院</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于研究的时间比较短，可能有不少错漏或者理解不到位的地方，欢迎大家提出自己的见解。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP源码分析之ConcurrentBag一</title>
      <link href="/2020/07/30/HikariCP-source-code-8/"/>
      <url>/2020/07/30/HikariCP-source-code-8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><p>大家好，今天我们一起分析下 HikariCP 的核心ConcurrentBag，它是管理连接池的最重要的核心类。从它的名字大家可以看得出来，它是一个并发管理类，性能非常好，这是它性能甩其他连接池十条街的秘密所在。</p><h3 id="代码概览"><a href="#代码概览" class="headerlink" title="代码概览"></a>代码概览</h3><p>我们先看一下代码，注意这不是全部的代码，省略了不太重要的部分。大家可以看到我加了非常详细的注释，对详解不太感兴趣的朋友可以直接读一下代码即可，不过这部分历时好几个夜晚我才写完，大家可以稍稍捧个场：</p><pre><code class="java">//可用连接同步器, 用于线程间空闲连接数的通知, synchronizer.currentSequence()方法可以获取当前数量//其实就是一个计数器, 连接池中创建了一个连接或者还回了一个连接就 + 1, 但是连接池的连接被借走, 是不会 -1 的, 只加不减//用于在线程从连接池中获取连接时, 查询是否有空闲连接添加到连接池, 详见borrow方法private final QueuedSequenceSynchronizer synchronizer;//sharedList保存了所有的连接private final CopyOnWriteArrayList&lt;T&gt; sharedList;//threadList可能会保存sharedList中连接的引用private final ThreadLocal&lt;List&lt;Object&gt;&gt; threadList;//对HikariPool的引用, 用于请求创建新连接private final IBagStateListener listener;//当前等待获取连接的线程数private final AtomicInteger waiters;//标记连接池是否关闭的状态private volatile boolean closed;/** * 该方法会从连接池中获取连接, 如果没有连接可用, 会一直等待timeout超时 * * @param timeout  超时时间 * @param timeUnit 时间单位 * @return a borrowed instance from the bag or null if a timeout occurs * @throws InterruptedException if interrupted while waiting */public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedException {   //①   //先尝试从ThreadLocal中获取   List&lt;Object&gt; list = threadList.get();   if (weakThreadLocals &amp;&amp; list == null) {      //如果ThreadLocal是 null, 就初始化, 防止后面 npe      list = new ArrayList&lt;&gt;(16);      threadList.set(list);   }   //②   //如果ThreadLocal中有连接的话, 就遍历, 尝试获取   //从后往前反向遍历是有好处的, 因为最后一次使用的连接, 空闲的可能性比较大, 之前的连接可能会被其他线程偷窃走了   for (int i = list.size() - 1; i &gt;= 0; i--) {      final Object entry = list.remove(i);      @SuppressWarnings(&quot;unchecked&quot;) final T bagEntry = weakThreadLocals ? ((WeakReference&lt;T&gt;) entry).get() : (T) entry;      if (bagEntry != null &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {         return bagEntry;      }   }   //③   //如果没有从ThreadLocal中获取到连接, 那么就sharedList连接池中遍历, 获取连接, timeout时间后超时   //因为ThreadLocal中保存的连接是当前线程使用过的, 才会在ThreadLocal中保留引用, 连接池中可能还有其他空闲的连接, 所以要遍历连接池   //看一下requite(final T bagEntry)方法的实现, 还回去的连接放到了ThreadLocal中   timeout = timeUnit.toNanos(timeout);   Future&lt;Boolean&gt; addItemFuture = null;   //记录从连接池获取连接的开始时间, 后面用   final long startScan = System.nanoTime();   final long originTimeout = timeout;   long startSeq;   //将等待连接的线程计数器加 1   waiters.incrementAndGet();   try {      do {         // scan the shared list         do {            //④            //当前连接池中的连接数, 在连接池中添加新连接的时候, 该值会增加            startSeq = synchronizer.currentSequence();            for (T bagEntry : sharedList) {               if (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {                  // if we might have stolen another thread&#39;s new connection, restart the add...                  //⑤                  //如果waiters大于 1, 说明除了当前线程之外, 还有其他线程在等待空闲连接                  //这里, 当前线程的addItemFuture是 null, 说明自己没有请求创建新连接, 但是拿到了连接, 这就说明是拿到了其他线程请求创建的连接, 这就是所谓的偷窃了其他线程的连接, 然后当前线程请求创建一个新连接, 补偿给其他线程                  if (waiters.get() &gt; 1 &amp;&amp; addItemFuture == null) {                     //提交一个异步添加新连接的任务                     listener.addBagItem();                  }                  return bagEntry;               }            }         } while (startSeq &lt; synchronizer.currentSequence()); //如果连接池中的空闲连接数量比循环之前多了, 说明有新连接加入, 继续循环获取         //⑥         //循环完一遍连接池(也可能循环多次, 如果正好在第一次循环完连接池后有新连接加入, 那么会继续循环), 还是没有能拿到空闲连接, 就请求创建新的连接         if (addItemFuture == null || addItemFuture.isDone()) {            addItemFuture = listener.addBagItem();         }         //计算 剩余的超时时间 = 用户设置的connectionTimeout - (系统当前时间 - 开始获取连接的时间_代码①处 即从连接池中获取连接一共使用的时间)         timeout = originTimeout - (System.nanoTime() - startScan);      } while (timeout &gt; 10_000L &amp;&amp; synchronizer.waitUntilSequenceExceeded(startSeq, timeout)); //③      //⑦      //这里的循环条件比较复杂      //1. 如果剩余的超时时间, 大于10_000纳秒      //2. startSeq的数量, 即空闲连接数超过循环之前的数量      //3. 没有超过超时时间timeout      //满足以上 3 个条件才会继续循环, 否则阻塞线程, 直到满足以上条件      //如果一直等到timeout超时时间用完都没有满足条件, 结束阻塞, 往下走      //有可能会动态改变的条件, 只有startSeq数量改变, 是②处添加的创建连接请求   } finally {      waiters.decrementAndGet();   }   return null;}/** * 该方法将借出去的连接还回到连接池中 * 不通过该方法还回的连接会造成内存泄露 * * @param bagEntry the value to return to the bag * @throws NullPointerException  if value is null * @throws IllegalStateException if the requited value was not borrowed from the bag */public void requite(final T bagEntry) {   //⑧   //lazySet方法不能保证连接会立刻被设置成可用状态, 这是个延迟方法   //这是一种优化, 如果要立即生效的话, 可能会需要使用volatile等, 让其他线程立即发现, 这会降低性能, 使用lazySet浪费不了多少时间, 但是不会浪费性能   bagEntry.lazySet(STATE_NOT_IN_USE);   //⑨   //将连接放回到threadLocal中   final List&lt;Object&gt; threadLocalList = threadList.get();   if (threadLocalList != null) {      threadLocalList.add(weakThreadLocals ? new WeakReference&lt;&gt;(bagEntry) : bagEntry);   }   //通知等待线程, 有可用连接   synchronizer.signal();}/** * 在连接池中添加一个连接 * 新连接都是添加到sharedList中, threadList是sharedList中的部分连接的引用 * * @param bagEntry an object to add to the bag */public void add(final T bagEntry) {   if (closed) {      LOGGER.info(&quot;ConcurrentBag has been closed, ignoring add()&quot;);      throw new IllegalStateException(&quot;ConcurrentBag has been closed, ignoring add()&quot;);   }   //⑩   sharedList.add(bagEntry);   synchronizer.signal();}/** * 从连接池中移除一个连接. * 这个方法只能用于从&lt;code&gt;borrow(long, TimeUnit)&lt;/code&gt; 或者 &lt;code&gt;reserve(T)&lt;/code&gt;方法中获取到的连接 * 也就是说, 这个方法只能移除处于使用中和保留状态的连接 * * @param bagEntry the value to remove * @return true if the entry was removed, false otherwise * @throws IllegalStateException if an attempt is made to remove an object *                               from the bag that was not borrowed or reserved first */public boolean remove(final T bagEntry) {   //⑪   //尝试标记移除使用中和保留状态的连接, 如果标记失败, 就是空闲的连接, 直接返回 false   //也就是检查连接的状态, 不能移除空闲的连接或者已经标记移除的连接   if (!bagEntry.compareAndSet(STATE_IN_USE, STATE_REMOVED) &amp;&amp; !bagEntry.compareAndSet(STATE_RESERVED, STATE_REMOVED) &amp;&amp; !closed) {      LOGGER.warn(&quot;Attempt to remove an object from the bag that was not borrowed or reserved: {}&quot;, bagEntry);      return false;   }   //如果上面标记成功了, 那么从连接池中移除这个连接   final boolean removed = sharedList.remove(bagEntry);   if (!removed &amp;&amp; !closed) {      LOGGER.warn(&quot;Attempt to remove an object from the bag that does not exist: {}&quot;, bagEntry);   }   // synchronizer.signal();   return removed;}</code></pre><p>上面的代码是ConcurrentBag中的成员变量和最重要的四个方法，ConcurrentBag中的属性我们穿插在代码中解释。</p><h3 id="borrow方法"><a href="#borrow方法" class="headerlink" title="borrow方法"></a>borrow方法</h3><p>borrow方法应该是整个 HikariCP 中最最核心的方法，它是我们从连接池中获取连接的时候最终会调用到的方法，一切秘密都在这里了。我们分析下：</p><h4 id="①ThreadLocal"><a href="#①ThreadLocal" class="headerlink" title="①ThreadLocal"></a>①ThreadLocal</h4><pre><code class="java">//①//先尝试从ThreadLocal中获取List&lt;Object&gt; list = threadList.get();if (weakThreadLocals &amp;&amp; list == null) {  //如果ThreadLocal是 null, 就初始化, 防止后面 npe  list = new ArrayList&lt;&gt;(16);  threadList.set(list);}</code></pre><p><code>threadList</code>是在ConcurrentBag上的成员变量，它的定义是<code>private final ThreadLocal&lt;List&gt; threadList;</code>，可见它是一个<code>ThreadLocal</code>，也就是每个线程都有独享的一个 <code>List</code>，它是用于保存当前线程用过的连接。注意这里我说的是”用过”，不是所有的连接。因为还有一个成员变量<code>private final CopyOnWriteArrayList&lt;T&gt; sharedList;</code>，它是真正的保存所有的连接的地方，它是一个<code>CopyOnWriteArrayList</code>，在写入的时候会先复制一个 <code>sharedList2</code>，然后修改这个新的 <code>sharedList2</code>，最后将变量地址指向新的<code>sharedList2</code>，不是直接写入当前的<code>sharedList</code>，典型的空间换时间的一个做法，可以避免写入前要锁住<code>sharedList</code>，从而导致降低性能。</p><p>HikariCP 使用过的连接，在还回连接池的时候，是直接放在了<code>ThreadLocal</code>中。说到这里，可能会有同学问了：<code>sharedList</code>中保存了所有的连接，当用户借走了一个连接，不是应该把这个连接从<code>sharedList</code>中移除，然后还回来的时候再把连接加入到<code>sharedList</code>中？为什么还回去的时候，没有放到<code>sharedList</code>中呢？</p><p>首先，明确一点，HikariCP 不是这样做的。为什么呢？如果用户借用连接的时候，你从<code>sharedList</code>中移除了，那么相当于这个连接脱离了 HikariCP 的管理，后面 HikariCP 还怎么管理这个连接呢？比如这个连接的生命周期到时间了，连接都让用户拐跑了，我还怎么关闭这个连接呢？所以，所有的连接都不能脱离掌控，一个都不能少。其实，我们在<code>sharedList</code>中保存的仅仅是数据库连接的引用，这些连接是所有的线程都可见的，各个线程也可以随意保存连接的引用，只是要使用的时候必须要走borrow方法，按流程来。</p><p>为什么要放到线程的<code>threadList</code>中？</p><p>因为下次获取的时候比较方便，也许会提高性能。每个线程都优先从自己的本地线程中拿，竞争的可能性大大降低啊，也许这个连接刚刚用完到再次获取的时间极短，这个连接很可能还空闲着。只有在本地线程中的连接都不能使用的时候，才去<code>sharedList</code>这个 HikariCP的总仓库里获取。</p><p>举一个生活例子：假如你是一个连锁店老板，提供汽车出租服务，有一个总仓库，所有的连锁店都从这里提车出租给用户。刚开始，你是每租一辆车都去仓库直接提货，用户还车的时候，你直接送到仓库。过了一段时间，你觉得这样不行啊，太浪费时间了，而且所有的连锁店都这样，各个店的老板都去提车，太忙了，还得排队。要不用户还回来的车先放店里吧，这样下次有用户租车就不用去仓库了，直接给他，方便很多，店里没车了再去总仓提车。其他连锁店都开始这么搞，大家都先用店里的车不够再去总仓。生意火爆，有一天店里没车了，你去仓库提车，仓库管理员说：仓库也没车了，天通苑的连锁店里有闲着的，你去那里提吧，于是你把天通苑连锁店的车借走了。所以各个连锁店之间也有相互借车。</p><p>例子可能不太恰当，一时也想不到同样道理的生活例子，但是就这个意思。HikariCP 也是这样，用户使用的连接，还回连接池的时候，直接放到线程的本地<code>threadList</code>中，如果用户又要借用连接，先看本地有没有，优先使用本地连接，只有本地没有或者都不可用的时候，再去 HikariCP 的连接池里获取。但是跟借车不同，因为我们本地是保存的<code>sharedList</code>中连接的引用，虽然你还有这个连接的引用，但是很可能它已经被其他线程从<code>sharedList</code>借走了，这就是HikariCP所谓的线程间的连接窃取。所以线程在本地的<code>threadList</code>就算拿到了连接，也必须检查下状态，是不是可用的。</p><p>说到这里，还没有解析代码，扯远了。①处代码就是先从本地的<code>threadList</code>里取出连接的 List，然后检查下List 是否为空，是空的直接初始化一个 List，因为下面要用到，防止抛空指针了。大家可以看到判空的时候，还有一个条件是<code>weakThreadLocals</code>，这个标识是表示<code>threadList</code>是否是弱引用。如果是弱引用，那么很可能 GC 的时候会被回收掉，所以变成 null 了，但是如果不是弱引用的话，那么它是在初始化ConcurrentBag的时候，就是一个FastList了，不用担心是 null。那么什么情况下<code>threadList</code>会是弱引用呢？当 HikariCP 运行在容器中时，会使用弱引用，因为在容器重新部署的时候，可能会导致发成内存泄露，具体大家可以看下#39 的 issue。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariConfig的配置解析</title>
      <link href="/2020/07/12/HikariCP-source-code-6/"/>
      <url>/2020/07/12/HikariCP-source-code-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h4 id="使用HikariConfig初始化-HikariCP"><a href="#使用HikariConfig初始化-HikariCP" class="headerlink" title="使用HikariConfig初始化 HikariCP"></a>使用HikariConfig初始化 HikariCP</h4><p>在《HikariCP源码分析之初始化分析一》中，我们解析了 HikariCP 的两种初始化方式，其中提到了使用<code>HikariConfig</code>的方式：</p><pre><code class="java">HikariConfig config = new HikariConfig();config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);config.setUsername(&quot;root&quot;);config.setPassword(&quot;123&quot;);//设置数据库独有的属性config.addDataSourceProperty(&quot;cachePrepStmts&quot;, &quot;true&quot;);//使用HikariConfig构造HikariDataSourceHikariDataSource dataSource = new HikariDataSource(config);//从连接池获取连接Connection connection = dataSource.getConnection();</code></pre><p>这种方式是官方推荐的使用方式，会对性能有一定的提升。<code>HikariConfig</code>其实就是 HikariCP 的配置类，我们前面介绍过的<code>HikariDataSource</code>继承了<code>HikariConfig</code>，所以我们也可以使用<code>HikariDataSource</code>直接初始化 HikariCP，但是这种方式性能比用<code>HikariConfig</code>稍差。</p><h4 id="重要的配置"><a href="#重要的配置" class="headerlink" title="重要的配置"></a>重要的配置</h4><p>我们今天分析下 HikariCP 中的配置，几乎所有的配置都在<code>HikariConfig</code>中，是<code>HikariConfig</code>的成员变量。我们看一下：</p><pre><code class="java">/* 可以在运行期通过JMX修改的属性 */   //从连接池获取连接时最大等待时间, 单位毫秒, 默认值 30秒, 至少 250ms   private volatile long connectionTimeout;   //检测连接是否有效的超时时间，单位毫秒, 默认 5000ms, 最小 250ms, 不能大于connectionTimeout   //   private volatile long validationTimeout;   //连接可以在池中的最大闲置时间, 单位毫秒, 至少 10s, 默认 10 分钟, 0 表示永不超时, 该配置不能大于maxLifetime   private volatile long idleTimeout;   //连接泄露检测的最大时间, 默认 0, 最低 2000毫秒; 也就是说, 连接从拿出连接池到还回连接池的总时间, 不能超出这个时间,超出的话就判定为泄露   private volatile long leakDetectionThreshold;   //连接最大存活时间, 单位毫秒, 最小允许值30000 ms, 默认30分钟, 推荐设置的比数据库的 wait_timeout 小几分钟   private volatile long maxLifetime;   //连接池中可以保留连接的最大数量, 比如: 100, 则连接池中的连接不能超过 100 个   private volatile int maxPoolSize;   //最小空闲连接数量, 默认 10 个, 也就是说, 连接池中最多可以保留 10 个空闲的连接, 多的会被关闭   private volatile int minIdle;   /* 在运行期不能修改的属性 */   //该属性设置一个SQL语句, 从连接池获取连接时, 先执行改 sql, 验证连接是否可用, 例子: select 1   //如果是使用了 JDBC 4 那么不建议配置这个选项, 因为JDBC 4 使用 ping 命令, 更加高效   private String connectionTestQuery;   //数据库驱动的dataSource类名, 与jdbcUrl, 必须二选一, 都配置的话, 优先使用该属性, 例子 : org.postgresql.ds.PGSimpleDataSource   private String dataSourceClassName;   private String dataSourceJndiName;   //数据库驱动类, 与dataSourceClassName不共存, 如果配置了这个属性, 那么jdbcUrl不能为空, 例子: com.mysql.jdbc.Driver   private String driverClassName;   //与dataSourceClassName, 必须二选一, 都配置的话, 忽略该属性, 例子: jdbc:mysql://localhost:3306/simpsons   private String jdbcUrl;   //必选, 数据库连接密码   private String password;   //连接池名称, 默认自动生成, Hikari 将它一般用于记录日志和 JMX 中, 如果有多个 Hikari 连接池, 建议配置一个有意义的名字   private String poolName;   private String transactionIsolationName;   //必选, 数据库连接用户名   private String username;   //自动提交事务, 默认值true   private boolean isAutoCommit;   //控制从池中获取的连接是否是只读模式, 需要数据库支持只读模式   private boolean isReadOnly;   //默认值true,是否快速失败,即在启动期间创建连接来验证关键参数是否有错误,如果不能建立连接,立即抛出错误,方便用户及时发现问题   private boolean isInitializationFailFast;   //   private boolean isIsolateInternalQueries;   //是否自动注册 JMX 相关的 bean, 用于运行时可以修改连接池设置   private boolean isRegisterMbeans;   //是否允许JMX 将连接池挂起   private boolean isAllowPoolSuspension;   //用户直接指定dataSource实例, 不使用 Hikari 创建的实例   private DataSource dataSource;</code></pre><p>上面不是所有的属性，一些不太重要的属性我们忽略掉。</p><p><code>HikariConfig</code>的配置可以分为两部分：可以在运行期修改的，不可以在运行期修改的。</p><h4 id="运行期可修改"><a href="#运行期可修改" class="headerlink" title="运行期可修改"></a>运行期可修改</h4><table><thead><tr><th>属性名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>connectionTimeout</td><td>从连接池获取连接时最大等待时间</td><td>默认值 30秒, 至少 250ms</td></tr><tr><td>validationTimeout</td><td>检测连接是否有效的超时时间</td><td>默认 5000ms, 最小 250ms, 不能大于connectionTimeout</td></tr><tr><td>idleTimeout</td><td>连接可以在池中的最大闲置时间</td><td>至少 10s, 默认 10 分钟, 0 表示永不超时, 该配置不能大于maxLifetime</td></tr><tr><td>leakDetectionThreshold</td><td>连接泄露检测的最大时间</td><td>默认 0表示不启用, 最低 2000毫秒</td></tr><tr><td>maxLifetime</td><td>连接最大存活时间</td><td>最小允许值30000 ms, 默认30分钟, 推荐设置的比数据库的 wait_timeout 小几分钟</td></tr><tr><td>maxPoolSize</td><td>连接池中可以保留连接的最大数量</td><td></td></tr><tr><td>minIdle</td><td>最小空闲连接数量</td><td>默认 10 个</td></tr></tbody></table><p>所谓的运行期可以修改的属性，就是可以使用 JMX 直接修改，我们再《HikariCP源码分析之获取连接流程二》中提到了作者推荐的用法，大家可以看一下。</p><h4 id="运行期不可修改"><a href="#运行期不可修改" class="headerlink" title="运行期不可修改"></a>运行期不可修改</h4><table><thead><tr><th>属性名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>connectionTestQuery</td><td>验证连接是否可用的 sql</td><td>例子: select 1，如果是使用了 JDBC 4 那么不建议配置这个选项, 因为JDBC 4 使用 ping 命令, 更加高效</td></tr><tr><td>dataSourceClassName</td><td>数据库驱动的dataSource类名</td><td>与jdbcUrl, 必须二选一, 都配置的话, 优先使用该属性, 例子 : org.postgresql.ds.PGSimpleDataSource</td></tr><tr><td>driverClassName</td><td>数据库驱动类</td><td>与dataSourceClassName不共存, 如果配置了这个属性, 那么jdbcUrl不能为空, 例子: com.mysql.jdbc.Driver</td></tr><tr><td>jdbcUrl</td><td>url</td><td>与dataSourceClassName, 必须二选一, 都配置的话, 忽略该属性, 例子: jdbc:mysql://localhost:3306/simpsons</td></tr><tr><td>password</td><td>数据库连接密码</td><td></td></tr><tr><td>username</td><td>数据库连接用户名</td><td></td></tr><tr><td>isRegisterMbeans</td><td>是否自动注册 JMX 相关的 bean</td><td>用于运行时可以修改连接池设置</td></tr><tr><td>isAllowPoolSuspension</td><td>是否允许JMX 将连接池挂起</td></tr></tbody></table><p>值得一提的是，如果要用 JMX 修改运行时配置，则必须配置<code>isRegisterMbeans</code>和<code>isAllowPoolSuspension</code>。</p><p>其实比较重要的是运行时可以修改的那几个配置，只要搞明白了他们的含义，大家就可以按照自己的情况修改。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariConfig初始化分析</title>
      <link href="/2020/07/12/HikariCP-source-code-7/"/>
      <url>/2020/07/12/HikariCP-source-code-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><p><code>HikariConfig</code>有 3 个构造方法，这三个构造方法其实都差不多，无我们逐个看一下：</p><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>第一个无参的构造，代码如下：</p><pre><code class="java">public HikariConfig() {      dataSourceProperties = new Properties();      healthCheckProperties = new Properties();      //①      minIdle = -1;      maxPoolSize = -1;      maxLifetime = MAX_LIFETIME;      connectionTimeout = CONNECTION_TIMEOUT;      validationTimeout = VALIDATION_TIMEOUT;      idleTimeout = IDLE_TIMEOUT;      isAutoCommit = true;      isInitializationFailFast = true;      //②      String systemProp = System.getProperty(&quot;hikaricp.configurationFile&quot;);      if (systemProp != null) {         loadProperties(systemProp);      }   }</code></pre><ul><li>①初始化默认值</li></ul><p>初始化默认值这部分，这些参数我们在《HikariConfig的配置解析》一文中都解析过这些参数，略过不提。</p><ul><li>②获取配置文件地址</li></ul><p>在这里首先尝试获取key 是<code>hikaricp.configurationFile</code>的配置文件地址，如果用户配置了，就会加载。我们可以在启动应用的时候使用<code>-D</code>指定。</p><p>我们详细看下<code>loadProperties</code>方法：</p><pre><code class="java">   protected void loadProperties(String propertyFileName) {      //①将propertyFileName当作一个路径, 直接加载文件      final File propFile = new File(propertyFileName);      //②判断propFile是一个文件, 就直接读取; 不是文件, 就继续查找, 加载不到, 直接报错      try (final InputStream is = propFile.isFile() ? new FileInputStream(propFile) : this.getClass().getResourceAsStream(propertyFileName)) {         if (is != null) {            Properties props = new Properties();            props.load(is);            //③            PropertyElf.setTargetFromProperties(this, props);         } else {            throw new IllegalArgumentException(&quot;Cannot find property file: &quot; + propertyFileName);         }      } catch (IOException io) {         throw new RuntimeException(&quot;Failed to read property file&quot;, io);      }   }</code></pre><ul><li>①加载文件</li></ul><p>尝试将propertyFileName当作一个路径, 直接加载文件</p><ul><li>②查找文件</li></ul><p>在此判断propFile是不是一个文件, 是文件就直接读取; 不是文件, 就继续查找。如果最后还是 加载不到, 直接直接报错。</p><ul><li>③获取属性</li></ul><p>将Properties文件中的配置，取出来 set 到<code>HikariConfig</code>中。</p><h4 id="配置赋值"><a href="#配置赋值" class="headerlink" title="配置赋值"></a>配置赋值</h4><p>我们看下实现：</p><pre><code class="java">public static void setTargetFromProperties(final Object target, final Properties properties) {      if (target == null || properties == null) {         return;      }      //①获取HikariConfig中的所有方法      List&lt;Method&gt; methods = Arrays.asList(target.getClass().getMethods());      //获取properties配置文件的所有配置项名称的集合, 例如dataSource.username = tom , 此处拿到的是dataSource.username这种等号左边的所有配置项      Enumeration&lt;?&gt; propertyNames = properties.propertyNames();      //遍历所有的配置项, 复制到HikariConfig中      while (propertyNames.hasMoreElements()) {         Object key = propertyNames.nextElement();         String propName = key.toString();         //获取配置项对应的值         Object propValue = properties.getProperty(propName);         if (propValue == null) {            propValue = properties.get(key);         }         //②如果不是HikariConfig的配置, 是dataSource的配置, 也就是数据库相关的配置, 就添加到DataSourceProperty中         // 因为每个数据库的配置可能不一样, 所有没有 setter 方法         if (target instanceof HikariConfig &amp;&amp; propName.startsWith(&quot;dataSource.&quot;)) {            ((HikariConfig) target).addDataSourceProperty(propName.substring(&quot;dataSource.&quot;.length()), propValue);         } else {            //③如果不是 dataSource配置, 那就调用 setter 方法, 给HikariConfig赋值            setProperty(target, propName, propValue, methods);         }      }   }</code></pre><p>在①处，通过反射获取到<code>HikariConfig</code>的所有方法，然后获取properties文件中所以的 key 值，遍历properties文件中的 所有key，将配置项一项一项的设置到<code>HikariConfig</code>中。</p><p>注释非常详细，但是要提醒大家的是，并不是所有的配置，HikariCP 都有对应的属性，有一些数据库独有的配置项，我们通常是使用<code>dataSource.XXX</code>来配置的，所以如果在properties文件中有以<code>dataSource.</code>开头的配置项，那么就是dataSource的配置，要放到</p><p>DataSourceProperty中，这些配置没有对应的 setter。③处的<code>setProperty</code>方法，就是一个比较普通的反射方式赋值的实现，大家看一下就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP获取连接流程源码分析三</title>
      <link href="/2020/07/06/HikariCP-source-code-3/"/>
      <url>/2020/07/06/HikariCP-source-code-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><p>话接上篇，我们继续分析HikariCP获取连接的过程。</p><h3 id="③拿到一个连接"><a href="#③拿到一个连接" class="headerlink" title="③拿到一个连接"></a>③拿到一个连接</h3><pre><code class="java">//③//获取连接的时候, 判断连接是否已经被标记移除if (poolEntry.isMarkedEvicted() || (clockSource.elapsedMillis(poolEntry.lastAccessed, now) &gt; ALIVE_BYPASS_WINDOW_MS &amp;&amp; !isConnectionAlive(poolEntry.connection))) {    //如果连接超出maxLifetime, 或者连接测试不通过, 就关闭连接    closeConnection(poolEntry, &quot;(connection is evicted or dead)&quot;); // Throw away the dead connection (passed max age or failed alive test)    //剩余超时时间    timeout = hardTimeout - clockSource.elapsedMillis(startTime);} </code></pre><p>如果<code>connectionBag</code>给我们返回了一个连接，那么需要判断两个条件：</p><ol><li><p>该连接是否被软驱逐了，<code>poolEntry.isMarkedEvicted()</code></p></li><li><p>该连接是否已经不可用了或者说已经不能通过连接检查，<code>!isConnectionAlive(poolEntry.connection)</code></p></li></ol><p>为什么需要判断呢？连接池里的连接不应该都是可用的状态吗？</p><p>这里涉及到 HikariCP 的一个设计点，HikariCP的连接不是实时从连接池里剔除的，只是给连接上打个标记而已，都是在获取连接的时候检查是否可用，如果不可用的时候才直接从连接池里删除。如果在 HikariCP的任何地方都可能剔除连接，那么剔除连接的地方会比较多，会很乱，也容易引发 bug。反之，把剔除链接的操作收缩到某几个固定的逻辑中，就比较好管理。</p><ul><li>软驱逐</li></ul><p>我们在上面提到一个软驱逐的地方， 就是挂起连接池修改配置的时候，修改完之后要软驱逐所以的连接，使新配置生效。</p><p>其实软驱逐是一个标记状态，是一个软删除，在<code>PoolEntry</code>上，有个状态叫做<code>evict</code>，如果是 true，那么，该连接已经被标记删除，不能使用了。然后某个线程在获取连接的时候，正好拿到了这个连接，判断出来它已经被软驱逐，就触发从连接池删除该连接的逻辑。</p><p>关闭连接的逻辑我们后面单独分析，此处就不深入了。</p><ul><li>连接可用检查</li></ul><p>检查连接是否可用的条件，其实是两个：<code>(clockSource.elapsedMillis(poolEntry.lastAccessed, now) &gt; ALIVE_BYPASS_WINDOW_MS &amp;&amp; !isConnectionAlive(poolEntry.connection)</code> 。它们使用 and 连接，也就是这两个条件都必须成立。<code>isConnectionAlive</code>方法比较好理解，我们从字面也能看出这个方法的作用，是判断连接是否还活着。那么前面的条件是什么呢？</p><p>我看其他的解析文章根本没有提到这里，我们是要解释一下的。</p><p><code>clockSource.elapsedMillis(poolEntry.lastAccessed, now)</code>这句代码里，<code>poolEntry.lastAccessed</code>是获取连接上次使用的时间，<code>now</code>是当前时间，那么<code>elapsedMillis</code>其实就是计算连接到现在多长时间没有被使用过了，结果是个毫秒数。</p><p><code>ALIVE_BYPASS_WINDOW_MS</code>的定义是<code>private final long ALIVE_BYPASS_WINDOW_MS = Long.getLong(&quot;com.zaxxer.hikari.aliveBypassWindowMs&quot;, MILLISECONDS.toMillis(500));</code>，它看起来像是一个配置项，默认值是 500 毫秒。这个配置你要是从文档里找的话，是没有的，因为这个配置作者没有透出给用户使用。但是你要是配置了，是管用的，只是作者不建议用户修改，所以不透出。它是什么呢？既然跟检查连接要同时成立，随便猜猜也知道跟它有关。不卖关子，它是检查连接是否活着的空窗期，也就是说，如果这个连接从上次使用到现在，不到 500 毫秒，就不检查它是否活着了，默认它活着；超过 500 毫秒，才检查一下。</p><p>看起来又是一个优化点对吧？是的，是一个优化点。因为检查连接是否还存活，是比较耗时的，要使用该连接跟数据库通信一次。</p><p>有两种通信方式：</p><ol><li>JDBC4 以下版本的驱动，使用用户配置的<code>connectionTestQuery</code>中的 sql 来检查。</li></ol><p><code>connectionTestQuery</code>是获取连接的时候，用于检查连接是否可用的一个 sql，大家可能用过，常见的是配置一个<code>select 1</code>。</p><ol start="2"><li>JDBC4 以上，如果不配置<code>connectionTestQuery</code>， 默认使用 ping 命令检查。</li></ol><p>如果使用的是 JDBC4 以上的驱动，建议大家不用配置<code>connectionTestQuery</code>，因为 ping 命令的方式比执行一个 sql 要高效很多。</p><p>不管是使用较慢的执行 sql 检查还是 较快的ping 命令检查，这都是一个耗时操作，所以作者设置了一个空窗期，不需要每次获取连接都检查，500毫秒内用过该连接，那么连接还正常的可能性极大，就不检查了，提高性能。</p><p>后面<code>closeConnection</code>我们先不说，后面的文章统一分析连接关闭。</p><h3 id="④连接可用"><a href="#④连接可用" class="headerlink" title="④连接可用"></a>④连接可用</h3><pre><code class="java">//④//记录连接借用metricsTracker.recordBorrowStats(poolEntry, startTime);//创建ProxyConnection, ProxyConnection是Connection的包装, 同时也创建一个泄露检测的定时任务return poolEntry.createProxyConnection(leakTask.schedule(poolEntry), now);</code></pre><p>如果第 3 步的检查全部通过，也就是拿到的连接是可用的，我们就要执行第 4 步了。</p><ul><li>上报监控平台</li></ul><p><code>metricsTracker</code>这一句，其实是记录连接的借用，不是我们通常使用的打印一下日志，而是上报给监控平台，HikariCP 是支持对接监控平台的。这里大家先知道这个逻辑，后面我们统一分析上报监控平台。</p><ul><li>为什么用代理连接？</li></ul><p>最主要的就是return 的这一句代码了吧。我们说过<code>poolEntry</code>是底层数据库连接的一个包装类，代表一个数据库连接。那么从<code>createProxyConnection</code>字面来看，这个方法并不是直接返回数据库连接给用户使用，而是创建了一个代理连接，这个代理连接是什么？为什么不直接返回数据库连接给用户使用？</p><p>不管我们使用 Spring 还是自己写的代码从 HikariCP 连接池里拿连接，都是拿到一个<code>java.sql.Connection</code>类型的对象没错吧？它是一个 java 统一的数据库连接接口，不管你使用的是 mysql 还是oracle 等数据库，都是统一对接这个接口，都必须返回一个这个类型的连接给用户使用，相当于一个门面模式的设计，这样用户可以不理会底层使用什么数据库，代码都是一个样的。既然如此，HikariCP应该直接返回一个<code>java.sql.Connection</code>对吧？</p><p>没有那么简单。试想一下，假如 HikariCP 直接返回底层的数据库连接给用户使用，那么，如果用户自己关闭了这个底层数据库连接呢？那么这个连接在连接池里相当于已经不可用了，其他线程也使用不了了。作为一个框架设计者，不能指望每个用户都是高手，他们都能在用完数据库连接不会关闭它并且要还回连接池中，肯定有小白用户或者很唬的不管三七二十一的人。更何况除了关闭连接，还有你修改了连接的设置呢，比如自动提交事务，连接只读这些设置，然后没有恢复回原来的设置怎么办？如此混乱的话，我们使用连接池就没有意义了。所以我们不能把底层数据库连接直接给用户使用，这个大家理解了吧？</p><p>如何来实现呢？我们可以继承<code>java.sql.Connection</code>，创建一个它的子类，子类可以直接当做父类来用，没错吧？然后我们在子类里覆盖<code>java.sql.Connection</code>里面敏感的操作，比如关闭连接，如果用户调用了关闭连接操作，不是真正的关闭底层连接，而是将连接还回到连接池。怎么样？我们解决了用户瞎用的问题了吧。作者就是这个目的，才设计了一个<code>createProxyConnection</code>方法来创建了一个连接的代理<code>ProxyConnection</code>，将这个代理返回给用户使用。一切如我们所说的，<code>ProxyConnection</code>继承了<code>java.sql.Connection</code>，覆盖了一些方法，详细的我们后面单独的文章解析，这里很重要。</p><ul><li>泄露检测</li></ul><p>我之前写过一个连接泄露检测的文章，是我写的浏览量最大的文章，这说明，有不少人都遇到这个问题。在 HikariCP 检测到连接泄露的时候，会抛出一个 warn：<code>java.lang.Exception: Apparent connection leak detected</code>。我们在这里详细说一下这个地方的逻辑。</p><ol><li>连接泄露检测的相关配置</li></ol><p>有一个<code>leakDetectionThreshold</code>的配置，这个就是连接泄露检测的最大时间，默认是 0，表示不启用泄露检测；最小值 2000 毫秒，如果用户设置的小于 2000 毫秒，默认关闭泄露检测，最大值不能超过连接的最大存活时间，也就是maxLifetime配置，超过的话也会自动禁用泄露检测。</p><ol start="2"><li>泄露检测的定时任务</li></ol><p>在<code>createProxyConnection</code>方法中，我们可以看到传了一个参数<code>leakTask.schedule(poolEntry)</code>。<code>leakTask</code>的类型是<code>ProxyLeakTask</code>，它实现了<code>Runnable</code>接口，是一个多线程的定时任务实现。它的内部持有几个成员变量：<code>ScheduledExecutorService</code>，是用来执行泄露检测定时任务的线程池；<code>leakDetectionThreshold</code>，是泄露检测超时时间；</p><p><code>scheduledFuture</code>是任务的 future 结果，可以用来取消定时任务。</p><p>我们看下它的<code>schedule</code>方法：</p><pre><code class="java">ProxyLeakTask schedule(final PoolEntry bagEntry) {      return (leakDetectionThreshold == 0) ? NO_LEAK : new ProxyLeakTask(this, bagEntry);   }</code></pre><p>这里判断了下用户有没有开启泄露检测功能，如果是没有开启，那么就返回一个<code>NO_LEAK</code>。大家还记得<code>FAUX_LOCK</code>吧？就是上面的①处令牌桶的实现，是提供了一个空实现对吧？这里也是同样的道理，<code>NO_LEAK</code>是一个空实现，如果用户没有开启泄露检测就方便 JIT 把这段逻辑优化掉。</p><p>OK，我们看下<code>new ProxyLeakTask(this, bagEntry)</code>的实现：</p><pre><code class="java">private ProxyLeakTask(final ProxyLeakTask parent, final PoolEntry poolEntry) {      this.exception = new Exception(&quot;Apparent connection leak detected&quot;);      this.connectionName = poolEntry.connection.toString();      scheduledFuture = parent.executorService.schedule(this, parent.leakDetectionThreshold, TimeUnit.MILLISECONDS);}</code></pre><p>大家仔细观察下这个构造方法，第一个参数也是一个<code>ProxyLeakTask</code>，看名字<code>parent</code>是个父任务。这个父任务在连接池初始化的时候会创建，创建的时候需要两个参数，一个是用于执行任务的线程池<code>executorService</code>，另一个是连接泄露超时时间<code>leakDetectionThreshold</code>。此处传递父任务进来就是要使用父任务中的线程池和连接泄露超时时间。</p><p>我们看下超时检测的任务实现：</p><pre><code class="java">public void run() {      final StackTraceElement[] stackTrace = exception.getStackTrace();      final StackTraceElement[] trace = new StackTraceElement[stackTrace.length - 5];      System.arraycopy(stackTrace, 5, trace, 0, trace.length);      exception.setStackTrace(trace);      LOGGER.warn(&quot;Connection leak detection triggered for {}, stack trace follows&quot;, connectionName, exception);   }</code></pre><p>由于这里不太重要，我们就不一句一句的分析了，整个<code>run</code>方法就是构造一个异常，然后抛出一个 warn 异常栈。</p><p>到此，我们整个连接泄露的分析就结束了。</p><ul><li>释放锁</li></ul><p>有一个需要注意的是，我们在最开始的第一句，是申请了一个令牌，现在上面已经获取到了可用连接，我们需要释放这个令牌。我们在使用其他锁的时候也是一样的，一定要在最后释放锁，为了防止任何异常打断代码执行，所以释放锁的代码一定要放在 finally 中，保证最后一定会把锁释放掉。</p><h3 id="⑤获取连接超时"><a href="#⑤获取连接超时" class="headerlink" title="⑤获取连接超时"></a>⑤获取连接超时</h3><p>上面整个获取连接的过程②③④代码是放在 do-while 中来执行的，只要不超过设置的<code>connectionTimeout</code>，就会一直尝试循环获取连接，直到超过了<code>connectionTimeout</code>，就会执行⑤的代码。超时之后有两个步骤：一是向监控平台上报获取连接超时；二是构造一个异常信息，然后抛出去。</p><p>至此，整个获取连接的逻辑就介绍完了，可能有一些没有说到的细节，大家可以发表意见，我们一起学习讨论。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP获取连接流程源码分析二</title>
      <link href="/2020/07/05/HikariCP-source-code-2/"/>
      <url>/2020/07/05/HikariCP-source-code-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h2 id="HikariPool的getConnection-方法"><a href="#HikariPool的getConnection-方法" class="headerlink" title="HikariPool的getConnection()方法"></a>HikariPool的getConnection()方法</h2><p>在上一篇《HikariCP获取连接流程源码分析一》中，我们分析了HikariDataSource的<code>getConnection()</code>方法，而这个方法，其实详细的实现细节都是在HikariPool的getConnection()方法中，我们来分析下HikariPool的getConnection()方法。</p><p>代码如下:</p><pre><code class="java">public final Connection getConnection() throws SQLException {      return getConnection(connectionTimeout);   }</code></pre><p>这里又调用了一个有参的getConnection()方法，但是我们并没有传参数connectionTimeout，这个是哪里来的呢？这个其实就是用户在初始化连接池的时候设置的参数<code>connectionTimeout</code>，它表示获取连接的超时时间，不配置的话默认值 30秒。我们继续看下<code>getConnection(connectionTimeout);</code>的实现：</p><pre><code class="java">public final Connection getConnection(final long hardTimeout) throws SQLException {      //①      //获取连接的时候申请令牌, 主要是为了连接池挂起的时候, 控制用户不能获取连接      //当连接池挂起的时候, Semaphore的 10000 个令牌都会被占用, 此处就会一直阻塞线程等待令牌      suspendResumeLock.acquire();      //记录获取连接的开始时间, 用于超时判断      final long startTime = clockSource.currentTime();      try {         long timeout = hardTimeout;         do {            //②            //从连接池获取连接, 超时时间timeout            final PoolEntry poolEntry = connectionBag.borrow(timeout, MILLISECONDS);            //borrow方法在超时的时候才会返回 null            if (poolEntry == null) {               break; // We timed out... break and throw exception            }            final long now = clockSource.currentTime();            //③            //获取连接的时候, 判断连接是否已经被标记移除            if (poolEntry.isMarkedEvicted() || (clockSource.elapsedMillis(poolEntry.lastAccessed, now) &gt; ALIVE_BYPASS_WINDOW_MS &amp;&amp; !isConnectionAlive(poolEntry.connection))) {               //如果连接超出maxLifetime, 或者连接测试不通过, 就关闭连接               closeConnection(poolEntry, &quot;(connection is evicted or dead)&quot;); // Throw away the dead connection (passed max age or failed alive test)               //剩余超时时间               timeout = hardTimeout - clockSource.elapsedMillis(startTime);            } else {               //④               //记录连接借用               metricsTracker.recordBorrowStats(poolEntry, startTime);               //创建ProxyConnection, ProxyConnection是Connection的包装, 同时也创建一个泄露检测的定时任务               return poolEntry.createProxyConnection(leakTask.schedule(poolEntry), now);            }         } while (timeout &gt; 0L);      } catch (InterruptedException e) {         throw new SQLException(poolName + &quot; - Interrupted during connection acquisition&quot;, e);      } finally {         //释放锁         suspendResumeLock.release();      }      //⑤      //获取连接超时才会执行下面的代码      logPoolState(&quot;Timeout failure &quot;);      metricsTracker.recordConnectionTimeout();      String sqlState = null;      final Throwable originalException = getLastConnectionFailure();      if (originalException instanceof SQLException) {         sqlState = ((SQLException) originalException).getSQLState();      }      final SQLException connectionException = new SQLTransientConnectionException(poolName + &quot; - Connection is not available, request timed out after &quot; + clockSource.elapsedMillis(startTime) + &quot;ms.&quot;, sqlState, originalException);      if (originalException instanceof SQLException) {         connectionException.setNextException((SQLException) originalException);      }      throw connectionException;   }</code></pre><h3 id="①Semaphore"><a href="#①Semaphore" class="headerlink" title="①Semaphore"></a>①Semaphore</h3><pre><code class="java">suspendResumeLock.acquire();//记录获取连接的开始时间, 用于超时判断final long startTime = clockSource.currentTime();</code></pre><p>getConnection的第一步，首先是获取令牌。我们从变量的名字<code>suspendResumeLock</code>来看，可能跟挂起(suspend)有关，那么挂起什么东西？如果之前大家有读过 HikariCP 的文档，或者使用过HikariCP的挂起功能，那么你肯定已经猜到了，这个是跟挂起整个连接池有关。</p><ul><li>挂起HikariCP</li></ul><p>HikariCP的挂起功能，其实就是暂停用户获取连接，也就是说，挂起整个连接池之后，如果有线程要从连接池获取连接，那么会一直阻塞，直到连接池被恢复。</p><p>挂起有什么用？</p><p>作者 brett 提到挂起的使用方法：</p><ol><li><p>挂起连接池</p></li><li><p>更改数据库连接池配置，或者更改 DNS 配置(指向新的主服务器)</p></li><li><p>软驱逐连接池中现有的连接</p></li><li><p>恢复连接池</p></li></ol><p>HikariCP可以在运行期通过 JMX修改一些配置的(并不是所有的配置)， 有：connectionTimeout（获取连接的超时时间），leakDetectionThreshold（连接泄露检测时间），maxPoolSize（连接池最大连接数），minIdle（最小空闲连接数），maxLifetime（连接最大存活时间），idleTimeout（连接最大空闲时间），共 7 项。</p><p>比如我挂起了连接池，然后修改了maxLifetime，那么连接池中现有的连接还是之前的配置，我就要将所有的连接都从连接池中驱逐出去，然后恢复连接池，这时候连接池就会使用新的配置创建新的连接。</p><p>除此之外，还可以使用连接池挂起时，线程一直阻塞无法获取到连接这个特性，来模拟数据库连接故障，来测试应用。</p><ul><li>怎么实现的</li></ul><p>OK，我们知道了这一句代码的目的主要是挂起连接池时，阻止用户获取连接的。那么是怎么实现的呢？</p><p>其实，<code>suspendResumeLock</code>的类是<code>com.zaxxer.hikari.util.SuspendResumeLock</code>，它的内部是用<code>Semaphore</code>实现的。<code>Semaphore</code>是 java 的concurrent包下的 并发工具类，它用给线程发放令牌的方式，控制线程的并发数量。</p><p>举个场景例子，假如是秒杀：我们知道服务器的最大并发处理能力是同时处理 1000 个请求，超过 1000 个请求服务器可能会宕机，在不扩容的情况下，尽量保证服务可用。这个时候，我们就要控制用户的请求数量不能超过 1000对吧。 </p><p>这时候我们可以用<code>Semaphore</code>实现，<code>Semaphore</code>类似一个令牌桶，桶里可以放指定数量的令牌，在并发的时候，每个线程从桶里拿一个(也可以是多个)令牌，拿到令牌的才可以继续执行，拿不到令牌的就等着(根据策略不同，也可能是抛异常等)，直到有其他线程释放令牌之后，得到令牌继续执行。</p><p>上面的场景，我们可以使用<code>Semaphore</code>初始化 1000 个令牌，每个线程拿一个令牌，这样我们就可以控制同时处理的请求数量不超过 1000了吧。</p><p>同样的道理，我们看下挂起连接池的方法：</p><pre><code class="java">public void suspend() {      //MAX_PERMITS = 10000      acquisitionSemaphore.acquireUninterruptibly(MAX_PERMITS);   }</code></pre><p>HikariCP 在这里初始化了 1万个令牌，如果用户调用了<code>suspend()</code>挂起连接池，其实就是调用了<code>Semaphore</code>一次获取 1 万个令牌，这样其他线程就没有令牌可以拿了，只能一直等，直到用户恢复线程池，释放这 1 万个令牌到桶里。</p><p>需要注意的是，要使用挂起连接池的功能，必须配置<code>isAllowPoolSuspension=true</code>，否则使用挂起功能会报错。</p><p>我们提到<code>isAllowPoolSuspension</code>其实是还要说一下suspendResumeLock的一个优化点。</p><p>在初始化连接池的时候，这个<code>suspendResumeLock</code>根据你是否开启了挂起功能，会有不同的实现，<code>this.suspendResumeLock = config.isAllowPoolSuspension() ? new SuspendResumeLock() : SuspendResumeLock.FAUX_LOCK;</code>。</p><p>假如没有启用挂起功能，那么<code>suspendResumeLock</code>是一个<code>FAUX_LOCK</code>。</p><p><code>FAUX_LOCK</code>是什么呢？看代码：</p><pre><code class="java">public static final SuspendResumeLock FAUX_LOCK = new SuspendResumeLock(false) {      @Override      public void acquire() {}      @Override      public void release() {}      @Override      public void suspend() {}      @Override      public void resume() {}   };</code></pre><p>你没有看错，就是一个空实现，方法里什么都没有。</p><p>这么做有什么好处？其实是，当挂起功能没有开启的时候, 它会提供一个空实现, 希望 JIT 能将之优化掉。也就是说，每次申请令牌其实是调用空方法，什么都不干，代码在运行多次之后，JIT 有可能会把它优化掉，根本就不调用了。这样，我们每次获取连接的时候，会节省申请令牌的额外开销，提高性能。</p><p>最快的一般不是浪得虚名，肯定都有值得我们学习的地方，除了最快的男人……你学会了没有？</p><p>我们继续分析。</p><p><code>clockSource</code>是一个时间的工具类，用于获取当前时间，计算时间差等等。此处记录了当前时间，用于后面时间差计算，判断获取连接是否超时用的。</p><h3 id="②获取连接"><a href="#②获取连接" class="headerlink" title="②获取连接"></a>②获取连接</h3><pre><code class="java">//②//从连接池获取连接, 超时时间timeoutfinal PoolEntry poolEntry = connectionBag.borrow(timeout, MILLISECONDS);//borrow方法在超时的时候才会返回 nullif (poolEntry == null) {  break; // We timed out... break and throw exception}</code></pre><p>此处的代码，我们可以看到，从<code>connectionBag</code>中获取了一个<code>poolEntry</code>对象。<code>poolEntry</code>其实是对数据库连接的一个包装类，<code>connectionBag</code>才是 HikariCP中实际保存数据库连接的容器，里面是一个<code>CopyOnWriteArrayList</code>。由于<code>connectionBag</code>非常重要，我们要在后面单独分析，此处不深入进去了。</p><p>但是从<code>connectionBag</code>获取连接的时候，我可以看到传了一个参数<code>timeout</code>，这个<code>timeout</code>就是我们配置的<code>connectionTimeout</code>，获取连接的超时时间，如果在指定的<code>timeout</code>时间内，没有返回一个连接，那么就返回一个 null。</p><p>此时已经超时了，所以下面的判断就是跳出循环，不在尝试获取连接了。</p><p>由于放在一篇文章里太长，未尽事宜，下篇继续！</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP源码分析之初始化分析一</title>
      <link href="/2020/07/05/HikariCP-source-code-4/"/>
      <url>/2020/07/05/HikariCP-source-code-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h2 id="HikariDataSource的初始化"><a href="#HikariDataSource的初始化" class="headerlink" title="HikariDataSource的初始化"></a>HikariDataSource的初始化</h2><p><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/07/05/HikariDataSource_init.png" alt="HikariDataSource_init"></p><p><code>HikariDataSource</code>是 HikariCP 开放给用户使用连接池的主要操作类。所以，我们创建一个 HikariCP 的连接池，其实就是构造一个<code>HikariDataSource</code>。</p><h4 id="两个构造函数"><a href="#两个构造函数" class="headerlink" title="两个构造函数"></a>两个构造函数</h4><p>它有两个构造函数：</p><p>第一个无参构造：</p><pre><code class="java">public HikariDataSource() {   super();   fastPathPool = null;}</code></pre><p>第二个有参构造:</p><pre><code class="java">public HikariDataSource(HikariConfig configuration) {  configuration.validate();  configuration.copyState(this);  LOGGER.info(&quot;{} - Started.&quot;, configuration.getPoolName());  pool = fastPathPool = new HikariPool(this);}</code></pre><h4 id="两种初始化方式"><a href="#两种初始化方式" class="headerlink" title="两种初始化方式"></a>两种初始化方式</h4><p>既然有两个构造函数，那么就应该有两种初始化方式，对吧。</p><ol><li>使用无参构造初始化</li></ol><pre><code class="java">HikariDataSource dataSource = new HikariDataSource();dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);dataSource.setUsername(&quot;root&quot;);dataSource.setPassword(&quot;123&quot;);//设置数据库独有的属性dataSource.addDataSourceProperty(&quot;cachePrepStmts&quot;, &quot;true&quot;);//从连接池获取连接Connection connection = dataSource.getConnection();</code></pre><ol start="2"><li>使用有参构造初始化</li></ol><pre><code class="java">HikariConfig config = new HikariConfig();config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);config.setUsername(&quot;root&quot;);config.setPassword(&quot;123&quot;);//设置数据库独有的属性config.addDataSourceProperty(&quot;cachePrepStmts&quot;, &quot;true&quot;);//使用HikariConfig构造HikariDataSourceHikariDataSource dataSource = new HikariDataSource(config);//从连接池获取连接Connection connection = dataSource.getConnection();</code></pre><p>这两种方式的区别就是，有参构造使用的是<code>HikariConfig</code>来设置参数的，有同学会问：既然<code>HikariDataSource</code>能直接设置参数，为什么还要用<code>HikariConfig</code>？这不是更麻烦吗？</p><p>其实 HikariCP 官方更推荐使用<code>HikariConfig</code>的方式，为什么呢？我们来具体分析下。</p><h4 id="无参构造代码分析"><a href="#无参构造代码分析" class="headerlink" title="无参构造代码分析"></a>无参构造代码分析</h4><p>我们先来分析第一种无参构造初始化的方式，代码只有两行：</p><pre><code class="java">super();fastPathPool = null;</code></pre><p><code>super();</code>方法是调用了<code>HikariDataSource</code>父类的无参构造，它的父类是哪个？是<code>HikariConfig</code>，这就是为什么<code>HikariDataSource</code>也能直接设置参数的原因，它继承了<code>HikariConfig</code>。那么这个<code>super();</code>肯定就是<code>HikariConfig</code>的无参构造了，我们看看：</p><pre><code class="java">public HikariConfig() {  //①  dataSourceProperties = new Properties();  healthCheckProperties = new Properties();  minIdle = -1;  maxPoolSize = -1;  //MAX_LIFETIME=30分钟  maxLifetime = MAX_LIFETIME;  //CONNECTION_TIMEOUT=30 秒  connectionTimeout = CONNECTION_TIMEOUT;  //VALIDATION_TIMEOUT=5 秒  validationTimeout = VALIDATION_TIMEOUT;  //IDLE_TIMEOUT=10分钟  idleTimeout = IDLE_TIMEOUT;  isAutoCommit = true;  isInitializationFailFast = true;  //②  String systemProp = System.getProperty(&quot;hikaricp.configurationFile&quot;);  if (systemProp != null) {     loadProperties(systemProp);  }}</code></pre><ul><li>①</li></ul><p>此处的代码，看起来就是执行了一些参数的初始化，给这些参数赋予默认值。具体的默认值，我已经在注释中写出来了。</p><ul><li>②</li></ul><p>此处的代码有点意思，<code>System.getProperty</code>是一个获取系统属性的方法，从字面看，它要获取一个叫做<code>hikaricp.configurationFile</code>的属性值，然后加载它。那么<code>hikaricp.configurationFile</code>配置的是什么东西呢？其实，这个是一个Properties配置文件的路径，它这是要从这个路径加载配置文件对吧。那么，我们又知道了一种 HikariCP 的配置方式：写一个Properties配置文件，然后将文件路径配置到<code>hikaricp.configurationFile</code>系统属性，就可以了。</p><p>又如何配置系统属性呢？很简单的，在应用启动的时候，使用<code>-Dhikaricp.configurationFile=xxxxx.properties</code>就可以了吧。</p><p>至于<code>loadProperties</code>如何加载配置文件并set 到对应的配置中，这个没有什么特殊的设计，在这里不展开了，后面给大家分析下<code>HikariConfig</code>的几种初始化方式，大家也可以看下我的代码注释，非常详细。</p><p>构造函数的最后一句<code>fastPathPool = null;</code>，如果大家看了《HikariCP源码分析之获取连接流程一》那么你一定明白的。</p><h4 id="有参构造代码分析"><a href="#有参构造代码分析" class="headerlink" title="有参构造代码分析"></a>有参构造代码分析</h4><p>我们继续看一下有参构造的代码：</p><pre><code class="java">configuration.validate();configuration.copyState(this);LOGGER.info(&quot;{} - Started.&quot;, configuration.getPoolName());pool = fastPathPool = new HikariPool(this);</code></pre><p>第一句<code>configuration.validate();</code>，是验证配置的参数。为了避免文章过长，我们另起章节介绍，毕竟文章不像是人体的某部位，越长越好，技术文章太长没人看，现在是流行碎片化阅读。</p><p>第二句<code>configuration.copyState(this);</code>我们要详细介绍下，这个跟本节关系密切。</p><p>从字面来看，是复制状态之类的操作。不知道<code>configuration.copyState(this);</code>方法中的参数的<code>this</code>大家注意了没有，它代表的是<code>HikariDataSource</code>对吧，而<code>configuration</code>代表的是<code>HikariConfig</code>。我们大胆猜测一下：应该是把<code>HikariConfig</code>中的配置复制到<code>HikariDataSource</code>中。</p><p>对不对呢？进去看下<code>copyState</code>代码：</p><pre><code class="java">public void copyState(HikariConfig other) {  for (Field field : HikariConfig.class.getDeclaredFields()) {     if (!Modifier.isFinal(field.getModifiers())) {        field.setAccessible(true);        try {           field.set(other, field.get(this));        } catch (Exception e) {           throw new RuntimeException(&quot;Failed to copy HikariConfig state: &quot; + e.getMessage(), e);        }     }  }}</code></pre><p> 果然不出所料，这是一段反射代码，目的就是把<code>HikariConfig</code>中的值复制到<code>this</code>代表的<code>HikariDataSource</code>实例中。为什么可以直接反射复制？因为<code>HikariDataSource</code>继承了<code>HikariConfig</code>啊，这个大家没有忘记吧！具体复制逻辑我就不说了，如果有同学看不懂这段反射，请补习Java反射的内容，这是 Java 基础，不是框架的内容。</p><p>略过第三句记录日志，我们直接看第四句<code>pool = fastPathPool = new HikariPool(this);</code>。</p><p>为什么要<code>pool = fastPathPool</code>， 请大家看《HikariCP源码分析之获取连接流程一》，你会明白的。我们直接看<code>new HikariPool(this)</code>，这是创建<code>HikariPool</code>，<code>HikariPool</code>是连接池的抽象，它提供了操作连接池的方法。</p><p>感觉已经够长了，换阵地，请看下一篇。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP源码分析之初始化分析二</title>
      <link href="/2020/07/05/HikariCP-source-code-5/"/>
      <url>/2020/07/05/HikariCP-source-code-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h2 id="HikariPool的初始化"><a href="#HikariPool的初始化" class="headerlink" title="HikariPool的初始化"></a>HikariPool的初始化</h2><p>在上一节，我们说到了<code>pool = fastPathPool = new HikariPool(this);</code>中的<code>new HikariPool(this)</code>。我们来看下代码：</p><pre><code class="java">public HikariPool(final HikariConfig config) {  //①  //PoolBase  super(config);  //②  // 构建一个connectionBag用于保存连接, connectionBag是连接池的核心  this.connectionBag = new ConcurrentBag&lt;&gt;(this);  //初始化连接计数器, 用于统计连接池中的连接数量  this.totalConnections = new AtomicInteger();  //根据是否允许挂起连接池, 初始化锁  this.suspendResumeLock = config.isAllowPoolSuspension() ? new SuspendResumeLock() : SuspendResumeLock.FAUX_LOCK;  //③  //连接池统计  if (config.getMetricsTrackerFactory() != null) {     setMetricsTrackerFactory(config.getMetricsTrackerFactory());  } else {     setMetricRegistry(config.getMetricRegistry());  }  setHealthCheckRegistry(config.getHealthCheckRegistry());  //注册 JMX 相关的 bean  registerMBeans(this);  //④  checkFailFast();  //⑤  ThreadFactory threadFactory = config.getThreadFactory();  this.addConnectionExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + &quot; connection adder&quot;, threadFactory, new ThreadPoolExecutor.DiscardPolicy());  this.closeConnectionExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + &quot; connection closer&quot;, threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());  if (config.getScheduledExecutorService() == null) {     threadFactory = threadFactory != null ? threadFactory : new DefaultThreadFactory(poolName + &quot; housekeeper&quot;, true);     this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());     this.houseKeepingExecutorService.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);     this.houseKeepingExecutorService.setRemoveOnCancelPolicy(true);  } else {     this.houseKeepingExecutorService = config.getScheduledExecutorService();  }  //⑥  //默认 30s 运行一次  this.houseKeepingExecutorService.scheduleWithFixedDelay(new HouseKeeper(), 0L, HOUSEKEEPING_PERIOD_MS, MILLISECONDS);  //⑦  this.leakTask = new ProxyLeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);}</code></pre><p>可以看到代码非常的长，也比较复杂，不要紧，我们慢慢分析。</p><h3 id="①初始化父类"><a href="#①初始化父类" class="headerlink" title="①初始化父类"></a>①初始化父类</h3><p><code>super(config);</code>中的 <code>super</code>代表的是<code>com.zaxxer.hikari.pool.PoolBase</code>。<code>PoolBase</code>是一个更接近底层的一个连接池抽象。它里面定义了一些数据库连接相关的配置，比如：是否自动提交事务，是否连接只读，是否使用 JDBC4，网络请求超时时间等。一些比较重要的方法：初始化 JDBC 的dataSource，验证连接是否存活，重置连接默认配置等等。调用<code>super(config);</code>的目的，就是初始化<code>PoolBase</code>中的这些数据库配置。</p><p>通过这个<code>super</code>我们可以发现，HikariCP的初始化是逐层传递的，假如某个子类继承了父类，父类又继承了它的父类，那么初始化的时候，是用同一个配置类，先传递到子类，再到父类，再到祖父类，每一层都使用<code>HikariConfig</code>来初始化跟自己相关的配置，我们可以学习这种初始化方式，非常优雅。</p><p>具体的<code>PoolBase</code>初始化过程，我们不深入了，不是很复杂，大家可以结合我的代码注释来看一下，注释的非常明白。</p><h3 id="②初始化ConcurrentBag"><a href="#②初始化ConcurrentBag" class="headerlink" title="②初始化ConcurrentBag"></a>②初始化ConcurrentBag</h3><p><code>ConcurrentBag</code>是一个通用的池模型的容器，是整个 HikariCP 的核心，我们要单独章节分析，此处大家只是明白这里初始化了用于保存数据库连接的容器，它的内部是一个<code>CopyOnWriteArrayList</code>，用于保存连接。</p><p><code>totalConnections</code>呢，从字面就可以理解，是一个连接的计数器，用于记录连接池中的连接数量。它的类型是<code>AtomicInteger</code>，关于<code>Atomic</code>开头的原子类，我们在《HikariCP源码分析之获取连接流程一》中详细分析过<code>AtomicBoolean</code>的原理，这个是差不多的，大家可以看前面的文章。<code>totalConnections</code>这个计数器，会在向连接池中添加新连接的时候加1，连接池中的连接被关闭之后会减 1。</p><p><code>suspendResumeLock</code>是我们在《HikariCP源码分析之获取连接流程二》中分析的重点，此处不赘述了。这里是创建一个连接池挂起的锁，或者说令牌桶，用于连接池挂起的时候，控制用户不能从连接池获取连接的。如果用户没有开启连接池挂起功能，就创建一个空的锁实现<code>FAUX_LOCK</code>，方便 JIT 将它优化掉。</p><h3 id="③监控初始化"><a href="#③监控初始化" class="headerlink" title="③监控初始化"></a>③监控初始化</h3><p>我们在之前的获取连接的分析文章中提到过，获取连接的时候，会向监控平台上报自己的状态，这里就是初始化监控平台的相关配置。用户可以自定义监控平台的实现，将它注册到 HikariCP 中，就可以被 HikariCP 调用。</p><p>值得一提的是<code>registerMBeans(this);</code>这一句代码。这里是注册 JMX 相关的 MBean，只有配置了数据库的<code>isRegisterMbeans</code>配置项，HikariCP 才会注册MBean，我们才能使用 JMX 在运行期间修改连接池的配置。如果不配置<code>isRegisterMbeans</code>，那么使用 JMX 修改配置会报错。对 JMX 感兴趣的同学，可以自行学习下相关内容。</p><h3 id="④快速失败"><a href="#④快速失败" class="headerlink" title="④快速失败"></a>④快速失败</h3><p>这里只有一行代码<code>checkFailFast();</code>，但是我们单独拿出来了，这说明这里有点意思。</p><p>直接看看代码：</p><pre><code class="java">private void checkFailFast() {  if (config.isInitializationFailFast()) {     try {        newConnection().close();     } catch (Throwable e) {        try {           shutdown();        } catch (Throwable ex) {           e.addSuppressed(ex);        }        throw new PoolInitializationException(e);     }  }}</code></pre><p>代码看着不少，其实关键的没有多少。<code>isInitializationFailFast</code>是一个 HikariCP的配置项，它的默认值是 true。老规矩，先从字面意思猜测一下，好像是：初始化的时候快速失败的意思。再看一下下面的代码<code>newConnection().close();</code>，这是创建了一个连接，然后立即关闭了呀！综合以上线索，这是什么意思？其实非常好理解。就是在初始化 HikariCP 的时候，建立一个连接，然后立即关闭，如果有报错建立不了，就关闭整个连接池，抛错。</p><p>目的就是在启动期间，创建连接来验证关键参数是否有错误，如果不能建立连接，立即抛出错误,方便用户及时发现问题。比如：我们的数据库密码写错了。如果没有这个立即失败的验证，等你上线部署成功之后，第一次获取连接才能发现问题，这不就悲催了嘛，搞不好要挨骂的。</p><h3 id="⑤初始化线程池"><a href="#⑤初始化线程池" class="headerlink" title="⑤初始化线程池"></a>⑤初始化线程池</h3><p>HikariCP 中有几个线程池：</p><ul><li><p>closeConnectionExecutor ：用于执行关闭底层连接的线程池，只有一个线程，线程任务队列最大是连接池最大连接数，超出队列的任务，会不断重试添加。</p></li><li><p>addConnectionExecutor：用于执行添加新连接的线程池，只有一个线程，线程任务队列最大是连接池最大连接数，超出队列的任务，直接抛弃。</p></li><li><p>houseKeepingExecutorService：这是一个定时线程池，默认只有一个线程，它的作用比较多：用于执行检测连接泄露、关闭生存时间到期的连接、回收空闲连接、检测时间回拨。</p></li></ul><p><code>closeConnectionExecutor</code>的队列任务抛弃策略有点不一样，它会不断重试，是基于连接必须关闭的考虑，其他的任务直接抛弃是影响不大。</p><p>这里有两项配置可以影响线程池，一个是<code>scheduledExecutor</code>：用于提供给<code>houseKeepingExecutorService</code>用的线程池，如果用户不自定义，就使用默认的 1 个线程的线程池。另一个是<code>threadFactory</code>：用于生成线程池中的线程，HikariCP 会在生成线程池的时候，调用该线程工厂获取线程。</p><h3 id="⑥启动连接管理任务"><a href="#⑥启动连接管理任务" class="headerlink" title="⑥启动连接管理任务"></a>⑥启动连接管理任务</h3><p>看代码：</p><p><code>this.houseKeepingExecutorService.scheduleWithFixedDelay(new HouseKeeper(), 0L, HOUSEKEEPING_PERIOD_MS, MILLISECONDS);</code></p><p>这里向<code>houseKeepingExecutorService</code>线程池里提交了一个任务：每隔 30 秒，就执行一次<code>HouseKeeper</code>任务。这个任务的功能主要是：检测时间回拨，调整连接池里的连接。什么是时间回拨？比如服务器的系统时间不准，后来用户修改了服务器的系统时间，因为 HikariCP 是对时间敏感的框架，它靠定时任务来管理连接，如果系统时间变了，那么定时任务就不准确了。</p><p>有两种情况：</p><ul><li><p>一是用户调快了时间，这个时候，HikariCP 什么都不做，因为时间快了，只是加快了定时任务的执行，使连接更早过期，这个对连接池影响不大，因为连接池会自动添加新连接。</p></li><li><p>二是用户调慢了时间，也就是回退了时间。回退时间对 HikariCP 是有极大影响的，比如原来还差 1 秒执行的任务，现在可能要过 15秒之后才能执行了，这可能引发本来该存活时间到期的连接，不会过期了。所以，这个时候，HikariCP 会把连接池中所以的连接都软驱逐掉，使所有的连接都不可用，然后重新创建新连接。</p></li></ul><p>由于<code>HouseKeeper</code>任务比较复杂，我们单独的章节分析。</p><h3 id="⑦创建连接泄露检测任务的父任务"><a href="#⑦创建连接泄露检测任务的父任务" class="headerlink" title="⑦创建连接泄露检测任务的父任务"></a>⑦创建连接泄露检测任务的父任务</h3><p>看代码：</p><p> <code>this.leakTask = new ProxyLeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);</code></p><p>我们在《HikariCP源码分析之获取连接流程三》中分析连接泄露检测时候，提到过，用户获取到每个连接的时候，都会为该连接创建一个连接泄露检测的定时任务，在指定的时间内，抛出连接泄露警告。</p><p>在创建连接泄露检测任务的时候，会使用一个父任务的参数，从这个父任务中拿连接泄露的最大时间和用于执行任务的线程池，然后使用这两个参数创建任务。这个父任务，就是在这里创建的，创建的时候就是传了这两个参数：连接泄露的最大时间和用于执行任务的线程池。</p><p>至此，HikariDataSource初始化就分析完成了。大家有任何问题，可以提出来，我们一起讨论学习。</p>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP获取连接流程源码分析一</title>
      <link href="/2020/07/04/HikariCP-source-code-1/"/>
      <url>/2020/07/04/HikariCP-source-code-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源代码版本2.4.5-SNAPSHOT</p></blockquote><h2 id="HikariDataSource的getConnection-方法"><a href="#HikariDataSource的getConnection-方法" class="headerlink" title="HikariDataSource的getConnection()方法"></a>HikariDataSource的getConnection()方法</h2><p>HikariCP获取连接的方法是<code>com.zaxxer.hikari.HikariDataSource#getConnection()</code>， 这个方法在<code>HikariDataSource</code>类中。<code>HikariDataSource</code>类中是 HikariCP 提供用户使用的主要类，有获取连接，关闭连接池，剔除连接等方法。我们主要看一下<code>getConnection()</code>, 这是对外暴露的获取连接的方法，不管是Spring获取连接还是我们自己手工调用 HikariCP，都是调用这个方法从连接池中取连接。</p><p>代码如下：</p><pre><code class="java">public Connection getConnection() throws SQLException {      //①      if (isClosed()) {         throw new SQLException(&quot;HikariDataSource &quot; + this + &quot; has been closed.&quot;);      }      //②      if (fastPathPool != null) {         return fastPathPool.getConnection();      }      /**       * ③       * See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java       * GFC: 双重检查锁       * https://www.cnblogs.com/xz816111/p/8470048.html       * 如果是使用无参构造{@link #HikariDataSource()}初始化的HikariDataSource,那么默认是延迟构建HikariDataSource,       * 在第一次获取连接的时候才构建HikariDataSource       */      HikariPool result = pool;      //B才执行到这里      if (result == null) {         synchronized (this) {            result = pool;            if (result == null) {               validate();               //A 执行到打印日志               LOGGER.info(&quot;{} - Started.&quot;, getPoolName());               pool = result = new HikariPool(this);            }         }      }      return result.getConnection();   }</code></pre><p>其实一看，HikariDataSource的<code>getConnection()</code>代码还是非常简单的，更多的细节，放在了HikariPool的<code>getConnection()</code>方法中。</p><p>但是，我们还是要分析一下的，毕竟，我们看开源代码的目的是学习大师的设计和技巧。</p><h3 id="①检查连接池状态"><a href="#①检查连接池状态" class="headerlink" title="①检查连接池状态"></a>①检查连接池状态</h3><pre><code class="java">//①if (isClosed()) {   throw new SQLException(&quot;HikariDataSource &quot; + this + &quot; has been closed.&quot;);}</code></pre><p>这里的代码主要是判断连接池是不是已经关闭了，如果<code>isClosed()</code>返回 <code>true</code>，那么连接池已经关闭， 那么直接抛出异常。虽然是一个简单的判断，其实也有值得我们学习的地方。</p><p><code>isClosed()</code>方法实现只有一句代码：<code>return isShutdown.get();</code>，这个<code>isShutdown</code>其实就是一个连接池的关闭状态对吧？它有个<code>get()</code>方法，猜猜是个什么类型？ OK，它的声明是<code>private final AtomicBoolean isShutdown = new AtomicBoolean();</code>。</p><p>我们知道带<code>Atomic</code>前缀的一些类型，都是原子操作，它是线程安全的，在高并发情况下，能保证<code>isShutdown</code>的值在各个线程中是一致的，类似的还有<code>AtomicInteger</code>，<code>AtomicLong</code>等等，那么<code>AtomicBoolean</code>就是一个线程安全的布尔类型，这样就可以保证关闭连接池的时候，其他线程可以及时的感知到。</p><p> 那么线程不安全的原因是什么？</p><p>CPU 有一级缓存，二级缓存，三级缓存，还有内存。一级缓存，二级缓存，三级缓存是每个 CPU 核独享的，而内存是整个 CPU 共享的。在CPU计算的时候会把值从内存读取到最近的一级缓存中，这样的话，很可能在多个核之间，<code>isShutdown</code>的值不一致，这就是线程不安全。</p><p>那<code>AtomicBoolean</code>是如何保证多个核之间的线程数据一致呢？</p><p><code>AtomicBoolean</code>内部，有一个<code>private volatile int value;</code>的属性，用于记录Boolean的值，0 是 false，1 是 true。关键就是<code>volatile</code>修饰符，可以强制 CPU 在修改<code>value</code>的时候，必须要同步到内存中，而读取的时候，必须要从内存中读取。这样，各个线程之间就是数据一致了吧。但是，它也有个显而易见的劣处，大家看出来了吗，那就是会比较慢，因为它每次都有从内存中读取数据，这就是性能较差，对吧？所以我们只能在需要使用<code>volatile</code>的时候再用，不能滥用。</p><p>在我经验不多的年纪，写类似代码标记一个状态的时候，是直接在类中定义一个类成员变量，没有用<code>volatile</code>。现在想来还是太年轻了，好在那些状态对实时的要求不高，也没有出现什么问题。所以我们还是要多读源码，学习前辈的经验。</p><p>不知道有没有同学会感慨，都涉及到 CPU 了，好底层啊。那么大家继续学习 HikariCP 的源码会发现，很多代码都是考虑到了非常底层的优化，比如控制了字节码的大小，方便 JVM优化代码。另外大家也可以学习下Disruptor并发框架，也是一个涉及到 CPU 缓存优化的框架，好多大数据框架学习了它的设计，据说性能高到能把 CPU 跑冒烟。</p><p>越是了解底层，越能写出更好的代码。学习了这些优秀的框架，我的感慨是：那些年上大学睡的觉，终究是要还的，现在终于到时候了…….</p><h3 id="②-两个连接池？"><a href="#②-两个连接池？" class="headerlink" title="② 两个连接池？"></a>② 两个连接池？</h3><pre><code class="java">//②if (fastPathPool != null) {   return fastPathPool.getConnection();}</code></pre><p>这里的代码，又是非常简单，有没有设计？有！</p><p>它的实现是直接调用了<code>fastPathPool</code>的<code>getConnection()</code>方法对吧。但是请大家注意最后的 return语句，是<code>result.getConnection();</code>，这个<code>result</code>是<code>fastPathPool</code>吗？看下③处<code>HikariPool result = pool;</code>，这个<code>result</code>其实是<code>pool</code>。那么有点奇怪，HikariDataSource中有两个连接池？不会吧，谁会这么设计呢 ！那该如何解释？</p><p>其实在HikariDataSource中，还真的有两个连接池的成员变量。定义如下：</p><pre><code class="java">private final HikariPool fastPathPool;private volatile HikariPool pool;</code></pre><p>除了变量名字不同之外，他们的修饰符也不一样，<code>fastPathPool</code>是<code>final</code>的，<code>pool</code>是<code>volatile</code>的。<code>volatile</code>在上面已经解释过了，就是为了线程安全嘛，保证多线程情况下pool的值是一致的。<code>fastPathPool</code>呢，是<code>final</code>的，HikariDataSource初始化的时候必须赋值，之后就改不了了对吧。</p><p>其实这里涉及到了HikariCP 连接池的创建方式。HikariDataSource有两个构造方法，第一个是无参构造：</p><pre><code class="java">public HikariDataSource() {      super();      fastPathPool = null;   }</code></pre><p>第二个是有参的:</p><pre><code class="java">public HikariDataSource(HikariConfig configuration) {      configuration.validate();      configuration.copyState(this);      LOGGER.info(&quot;{} - Started.&quot;, configuration.getPoolName());      pool = fastPathPool = new HikariPool(this);   }</code></pre><p>我们不在此详细解析这两个构造方法了，我们只看这两个构造方法的最后一句，无参构造的是<code>fastPathPool = null;</code>，有参构造的是<code>pool = fastPathPool = new HikariPool(this);</code>。</p><p>那么， 我们可以推断出，如果使用无参构造初始化HikariDataSource，<code>fastPathPool</code>就永远是 <code>null</code>；如果使用有参构造初始化HikariDataSource，那么<code>fastPathPool</code>就永远跟<code>pool</code>是一样的。</p><p><code>fastPathPool</code>和<code>pool</code>都是<code>HikariPool</code>类型的对吧，<code>HikariPool</code>其实是代表了连接池。那么我们最初的问题，为什么使用了两个连接池的成员变量？我们在①处解析了volatile的劣处，性能略差，如果每次获取连接都从<code>pool</code>读取的话，是不是每次都要损失一些性能？所以我们在使用有参构造创建连接池的时候，将<code>fastPathPool</code>也赋值，那么我们从<code>fastPathPool</code>获取连接，相当于变相的不使用volatile，这样就能不损耗<code>volatile</code>的性能。<code>volatile</code>的主要目的就是在创建连接池的时候，如果有多个线程同时创建，不会创建出多个连接池。我们会在下面详细描述。</p><p>除了学习到这种设计之外，我们还可以知道，使用有参构造来初始化HikariDataSource会有一些性能提升，官方也推荐大家使用有参构造来初始化 HikariCP。其实这种性能提升不是非常大，但是 Hikari作者还是不放过一点点的让 HikariCP 更快的机会，这就是为什么 HikariCP 是最快的数据库连接池。</p><p>详细的性能测试结果，大家可以看下作者的回答:</p><p><a href="https://groups.google.com/forum/#!msg/hikari-cp/yAtDD-3Qzgo/MgnNPLUkPqEJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!msg/hikari-cp/yAtDD-3Qzgo/MgnNPLUkPqEJ</a></p><h3 id="③双重检查锁"><a href="#③双重检查锁" class="headerlink" title="③双重检查锁"></a>③双重检查锁</h3><pre><code class="java">//③HikariPool result = pool;//B才执行到这里if (result == null) {   synchronized (this) {      result = pool;      if (result == null) {         validate();         //A 执行到打印日志         LOGGER.info(&quot;{} - Started.&quot;, getPoolName());         pool = result = new HikariPool(this);      }   }}return result.getConnection();</code></pre><p>此处的代码，我相信大家都能看懂，就是检查连接池是不是 null，如果是 null，就创建一个连接池，然后从新创建的连接池中获取连接返回。</p><p>如果我只写到上面，那我就跟有一些源码解析的文章一样了，看了跟没看一样， 没有任何收获。这不是我们的目的。当初就是因为他们写的不详细，我看不明白，所以我才打算自己写，大家也才能看到这篇文章。我们的目的就是学习到代码背后的东西， 而不是写一篇<code>这个方法调用了这个方法，那个方法调用了那个方法</code>这种没有营养的东西，因为方法调用大家都能看懂。</p><p>闲话少叙，代码背后的东西来了。这里的设计就是：双重检查锁，英文名：double checked locking。其实在写文章之前，我也不知道它叫什么，只会写。那么，什么是双重检查锁？其实就是在加锁之前检查一下对象是否为 null，加锁之后再检查一遍对象是否为 null，这种结构就是双重检查锁。</p><p>为什么这么写？已经有了锁，肯定就只能有一个线程创建连接池啊，检查两次这不是多此一举吗？我曾经遇到一个多年经验的老手也这么问我，由于我当时不知道双重检查锁这个名字，我只能给他讲了一遍如下过程：</p><p>我们假如有两个线程(A, B)都在执行这个方法。A 执行快一点，拿到了锁，执行到了打印日志的地方，但是还没有创建连接池，此时连接池pool还是 null。此时 B 执行到了检查pool是否是null 的地方，因为此时pool是 null，所以 B 要去申请锁了。A 执行完创建连接池了，此时pool不是 null 了，同时释放了锁。B 拿到了锁，再判断一次pool是否是null，此时pool不是null了，那么就不创建连接池了。如果没有拿到锁之后的第二次判断，那么连接池会被 B再创建一次，这才是多此一举！</p><p>还有人问：那么直接在获取锁之后检查一次就可以了，为什么还要在获取锁之前检查一次呢？</p><p>因为锁这个东西，很耗性能，如果只有一个拿到锁之后的检查的话，相当于所有线程要排队检查是不是连接池已经创建了，相当于只能排队获取连接，这是不行的，我们要高性能！在拿锁之前判断的话，如果连接池已经创建了的话，我们就直接跳过拿锁，直接获取连接了，可以多线程，高并发！</p><p>到这里，这个双重检查锁还不完美！我们继续看：</p><p>我们知道，创建一个对象，可以大体分为 3 步：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象指向刚分配的内存空间</li></ol><p>有时候编译器和CPU 会在保证最后结果不变的情况下，对指令重排序，这就是 CPU 的乱序执行。上面的 3 步，可能会变成 132 来执行。也就是说，<code>pool</code>可能不是 null 了，但是它没有被初始化，这样调用的时候也会报错的。那怎么办？答案还是<code>volatile。`</code>pool<code>是一个</code>volatile<code>的，大家还记得吧？我们上面说了，它是保证线程安全的。此处还要解释</code>volatile<code>的第二个功能：可以阻止指令重排序。它是怎么阻止重排序的呢？它会对</code>pool`加入一个内存屏障，又称内存栅栏，是一个CPU指令，可以阻止对指令的重排序，所有的写（write）操作都将发生在读（read）操作之前。</p><p>这样，我们就可以完美的保证高并发下，连接池可以被正确的创建出来。</p><p>在 HikariCP 框架的使用上，我们可以得知，如果使用无参构造初始化HikariCP，其实是一个延迟初始化，在第一次获取连接的时候，才能初始化连接池。如果大家的应用，在启动之后可能有大量请求，导致大量数据库连接创建，那么使用无参构造可以会不太合适，会导致请求有阻塞，数据库压力加大。所以，不管在什么情况下，还是要推荐大家使用有参构造初始化 HikariCP。</p><p>关于双重检查锁，大家还可以参考如下资料继续学习：</p><ol><li><p><a href="http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java</a></p></li><li><p><a href="https://www.cnblogs.com/xz816111/p/8470048.html" target="_blank" rel="noopener">https://www.cnblogs.com/xz816111/p/8470048.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> HikariCP源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 源代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron 项目构建, 打包实践及避坑</title>
      <link href="/2020/05/17/electron-package/"/>
      <url>/2020/05/17/electron-package/</url>
      
        <content type="html"><![CDATA[<p>项目架构是React + electron，可以直接使用普通的 react 项目，然后加上electron配置。electron 配置可以从项目<code>https://github.com/electron/electron-quick-start.git</code>    中获取。</p><p>打包配置：</p><ul><li>首先在 package.json中添加打包工具依赖</li></ul><pre><code class="shell">&quot;devDependencies&quot;: {    &quot;electron-packager&quot;: &quot;^14.2.1&quot;  }</code></pre><ul><li>再添加如下配置</li></ul><p><code>&quot;homepage&quot;: &quot;.&quot;</code></p><ul><li>在package.json中的scripts添加如下打包命令</li></ul><pre><code class="shell">&quot;package&quot;: &quot;electron-packager . demo --platform=darwin --arch=x64 --out=/Users/test/build --electron-version=8.2.3 --overwrite&quot;</code></pre><p>注意事项：</p><ol><li><p>–platform 最好指定要打包的平台，不建议指定 all</p></li><li><p>–out 不用指定为 build，会出现打包之后没有 build 目录的问题，另外此处要使用绝对路径</p></li></ol><ul><li>配置 main.js</li></ul><p>好多博客中，贴出的加载应用的方式是，这样的</p><pre><code class="javascript">// 加载应用的 index.html  mainWindow.loadURL(&#39;file://&#39; + __dirname + &#39;/index.html&#39;)；</code></pre><p>或者是使用了 path 拼接等等，都可能会找不到文件，或者报错如下</p><pre><code class="javascript">electron Not allowed to load local resource</code></pre><p>使用如下方式即可：</p><pre><code class="javascript">mainWindow.loadFile(`./build/index.html`)</code></pre><p>另外，main.js 中如果有这个独立的方法，</p><pre><code class="javascript">app.on(&#39;activate&#39;, function () {    log.info(&quot;activate&quot;);    // On macOS it&#39;s common to re-create a window in the app when the    // dock icon is clicked and there are no other windows open.    if (BrowserWindow.getAllWindows().length === 0) {        createWindow();    }})</code></pre><p>建议注释掉，这个地方有个 bug，在应用启动过程中点击会报错，</p><pre><code class="javascript">Uncaught Exception:Error: Cannot create BrowserWindow before app is ready    at createWindow (/Users/test/Documents/wsWP/react-cn-mirrot/build/CN-Mirror-darwin-x64/CN-Mirror.app/Contents/Resources/app/main.js:11:24)    at App.&lt;anonymous&gt; (/Users/test/Documents/wsWP/react-cn-mirrot/build/CN-Mirror-darwin-x64/CN-Mirror.app/Contents/Resources/app/main.js:98:9)    at App.emit (events.js:210:5)</code></pre><p>我已经跟 electron 提了 issue，回复说会修复。</p><p>如果要使用这个方法，要放在app.whenReady()中。</p>]]></content>
      
      
      <categories>
          
          <category> 问题排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> 打包 </tag>
            
            <tag> 避坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HttpServletBean解析-02</title>
      <link href="/2020/04/01/HttpServletBean-02/"/>
      <url>/2020/04/01/HttpServletBean-02/</url>
      
        <content type="html"><![CDATA[<p>有一句名言：“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决（Any problem in computer science can be solved by anther layer of indirection）” 。</p><p>这就是为啥我们从servlet说到了HttpServlet还没有进入主题SpringMVC的源码的原因，中间加了太多层。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/zUhpPO.jpg" alt="HttpServletBean"></p><p>言归正传，看上图，上一节我们说道了HttpServlet，然后下面又是一个HttpServlet的子类，HttpServletBean，并且也是一个抽象类，这就是说明，HttpServletBean也不是主角，它也是一个中间层，用来解决一个问题的。</p><p>解决什么问题？答案就是：把配置文件中的init-param配置的参数，都转换成bean的成员变量，方便使用。这一层主要的就是解析servlet配置文件中的参数，有人可能会问了：为了这个单独搞一层值当的吗，这么费劲？</p><p>如果你自己研究各种开源代码的话，可能会发现，很多前辈们的设计，就是一个洋葱，洋葱心是一个核心功能，然后每个功能都抽象出一层，一层一层的往洋葱心上贴，到最后一个完整的洋葱就出来了。</p><p>为什么这么做呢？好处是什么？这么做其实是遵循了一个原则，叫单一职责，每一个抽象层就做一件事。</p><p>我们可以回忆下，Servlet：是servlet协议的一些约定方法，是核心。GenericServlet：提供了默认的生命周期管理，HttpServlet：提供了Http协议的Servlet实现。</p><p>这样每一层只做一件事，好处是万一要做任何定制都可以非常方便。</p><p>假如一层有多个功能，而你只想定制其中一个功能，那么你不得不把所有的功能都覆盖一遍，累不累？</p><p>当然这只是个普遍的规律，肯定有不是单一职责的层，大家不要较真。其实越往洋葱的外层，类聚合的接口越多，类的功能也越多，这个时候其实不是在做单一职责的设计了，是在使用单一职责设计出来的东西；也就是说，不是单纯的在做设计了，是在使用前面设计出来的结构解决问题，实现我们的目的。因为不管你做多少设计，最终的目的就是解决我们的问题，所以洋葱的最外层就是解决问题的地方了，这些地方当然也有设计了，只是不是单一职责罢了。</p><p>继续说HttpServletBean🤣，上面说了，它的目的是解析init-param配置参数</p><p><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/5KObU2.jpg" alt="HttpServletBean"></p><p>请大家注意：第一处，这个方法是主要逻辑，但是大家不知道注意到了没有，这是重写的的父类的方法；第二处是调用了自己的初始化方法，但是这个初始化方法没有东西，留给子类实现。这是一个设计，从servlet到现在的HttpServletBean，都是子类重写父类的init方法，然后自己的init，留给自己的子类去实现。这是设计模板类的诀窍，能让子类参与到初始化中，方便子类定制自己的东西。</p><p>这个方法的主体逻辑就是将init-param的参数解析成一个map，然后将这个map中的参数注入到子类的属性中，它的子类是FrameworkServlet，也是抽象的，所以最终是注入到DispatcherServlet中。只要配置的参数名字跟属性名匹配，就可以注入。</p><p>逻辑代码没有一句一句的解析，因为我个人觉得，刚开始研究一份源代码，最重要的是先理清大体的脉络和思路，让你不至于看着看着晕头转向，迷了路。我们只要摸清楚了大体的思路和方向，然后可以仔细研究每个方法的实现。方法实现非常的复杂，调用关系乱七八糟，如果你一开始就钻进去，最后很可能会处处碰壁，灰心丧气。</p><p>另外，阅读开源代码的注释非常重要，我们可以从注释中得知作者的设计意图，使用方法，注意事项等等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> servlet </tag>
            
            <tag> Spring </tag>
            
            <tag> mvc </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet和HttpServlet解析-01</title>
      <link href="/2020/04/01/Servlet-HttpServlet-01/"/>
      <url>/2020/04/01/Servlet-HttpServlet-01/</url>
      
        <content type="html"><![CDATA[<p>一个servlet应用，通常会包括两部分：容器和servlet应用。既然在研究SpringMVC源码，那么大家肯定知道servlet容器了，常见的就是tomcat；servlet应用呢，就是我们写的代码。我们需要把自己的代码部署到tomcat中运行，才能正常提供服务。</p><p>一个请求的流转大体上如下图：<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/gs1ujl.jpg" alt="Request"></p><ol><li>用户发送的请求，先被容器收到</li><li>容器把请求传递给servlet应用</li><li>servlet处理请求，生成一个Response</li><li>servlet将Response传给容器</li><li>容器将Response返回给用户</li></ol><p>第一个发现：<br>通过上面的流程，大家可以看出，容器和servlet应用之间，是有通信的，也就是调用。我们知道，两个组件之间通信，肯定要遵循一个共同的协议，也就是一个规范，才能相互识别通信的内容。鸡同鸭讲，就是这个道理，语言不通肯定讲不明白。那么servlet应用和容器之间的语言，也就是通信规范，是什么呢？就是servlet规范。</p><p>所以，这个servlet规范，如果你有兴趣，可以读一读：<a href="https://github.com/waylau/servlet-3.1-specification" target="_blank" rel="noopener">Servlet规范</a></p><p>第二个发现：<br>整个流程，除了第三步处理过程外，其他的流程几乎都是固定的，第三步就是我们的业务逻辑，是根据需求来定制的。所以我们可以把第一二四五步抽象出一个组件来方便大家使用，不需要每个人都自己实现一遍，这就是容器；然后第三步的业务逻辑让用户自己定制。这个像什么？是不是很像设计模式中的模板？这里可以看做一个模板的设计模式。ps:我们没法知道当时各位前辈的想法了，但是通过现有的东西，我们可以反推一下。</p><p>第三个发现：<br>既然我们抽象出两个组件，那么这两个组件之间也设计了一个规范，怎么实现呢？servlet规范中规定了几个方法，双方约定，容器会调用init方法，创建servlet；调用service方法， 把用户的请求传递给servlet应用处理；移除servlet服务的时候，调用destroy方法销毁servlet等等。那么，容器和servlet应用只要使用同一个接口就可以搞定了。</p><p>接下来，我们看看这个容器和servlet应用的公共接口：Servlet<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/by1KkY.jpg" alt="servlet"></p><p>其实没啥，就是按照约定，定义了几个方法。init和destroy是生命周期方法，service是处理请求的方法，getServletConfig是获取servlet配置信息，getServletInfo是获取当前servlet信息，比如作者，版本，版权等等。</p><p>我刚开始学习web编程的时候，先学习用原生的servlet来写代码，最后学框架。但是，大家回忆下，我们是继承了HttpServlet，而不是Servlet。</p><p>大家看下HttpServlet的继承关系：<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/ZhnSEa.jpg" alt="HttpServlet"></p><p>ServletConfig：这个接口抽象的是servlet的相关配置，比如我们定义的servlet名字等等。它是创建servlet的入参，也就是说容器在创建servlet的时候，会把servlet的配置传递进来，传的就是ServletConfig的实现，通过这个接口定义的方法，能拿到servlet的配置。如果你在写代码的时候需要用到servlet配置，那么可以通过调用ServletConfig的方法拿到。</p><p>Servlet：这个接口里定义的servlet规范中约定的方法，上面说过了。</p><p>GenericServlet：这个抽象类很有意思，它实现了ServletConfig和Servlet接口，然而它是抽象的，是一个不能实例化的servlet。为什么要抽象一个这个？答案有点狗血，是为了让你写servlet省事点！(源代码中的注释就是这么说的！)它把两个接口的方法聚合在一起，然后提供了一些默认实现（比如，log，init，destory等等）管理生命周期，实现ServletConfig接口是为了在servlet中可以拿到servlet配置。然后我们只要重写service方法就可以了，其他的不需要关心，相当于提供了一个通用的，协议无关的模板给你，是为了可以实现一个通用的servlet，前辈们想的周到不周到？为了我等菜鸟真是操碎了心！当然这个层次的抽象我们还是不能直接使用的，仍然非常的简陋。</p><p>HttpServlet：这个就容易理解了吧，是http协议的servlet实现，相当于又给我们提供了一个http协议的servlet模板。我们最常用的就是http协议了，然而http协议有很多请求方法（get，post，put等等），HttpServlet将各个请求方法拆分了出来，我们只要继承HttpServlet，实现需要用的请求方法就可以了。又是前辈们在帮我们省事，你不需要非常精通http协议，就能实现你的业务逻辑了。说道这个类，大家应该都学过，最原始的servlet web应用，继承它，实现doGet, doPost方法，就能提供服务了。</p><p>学习到这里，相信大家都理解了整个从Servlet到HttpServlet的设计意图：一方面就是前辈们在给我们庖丁解牛，给我们铺路，提供便利；另一方面就是这种设计非常灵活，对于不熟悉的人，你可以立即上手实现业务逻辑。对于熟悉的人，你可以各种自己定制实现你的想法。</p><p>总结起来这么设计的目的就是几个词：灵活，解耦，方便。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> servlet </tag>
            
            <tag> Spring </tag>
            
            <tag> mvc </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Class 字节码文件结构分析----附带逐字节码分析图</title>
      <link href="/2019/10/25/Java-class-file-analysis/"/>
      <url>/2019/10/25/Java-class-file-analysis/</url>
      
        <content type="html"><![CDATA[<p>今天给大家分享下Java Class字节码文件的结构解析。（文末附有详细大图）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>首先我们创建一个Java类，然后添加一些成员变量和方法，如下:</p><pre><code>public class Test {    String name = &quot;hello&quot;;    int size = 10;    long num = 100;    Double pi = 3.14;    public static void main(String[] args) {        Test test = new Test();        test.print();    }    public void print() {        System.out.print(name);    }}</code></pre><p>大家可以看到，这是一个非常简单的类，仅仅有几个基本类型的成员变量和两个简单的方法。这是为了我们分析Class文件方便起见，没有添加复杂的结构。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>然后大家可以用<code>javac</code>命令编译一下这个类。编译之后，我们就得到了一个class文件，用sublime之类的软件打开这个class文件，我们可以看到如下信息:</p><pre><code>CA FE BA BE 00 00 00 34 00 40 0A 00 11 00 29 0800 2A 09 00 0C 00 2B 09 00 0C 00 2C 05 00 00 0000 00 00 00 64 09 00 0C 00 2D 06 40 09 1E B8 51..........00 00 00 0C 00 01 00 00 00 0B 00 1F 00 20 00 0000 01 00 27 00 00 00 02 00 28            </code></pre><p>是一行一行的十六进制的字符，每两个字符是一个字节，每个字节之间用空格分隔，我省略掉了中间的多行数据，如果要看完整数据，请看文末。<br>这些就是编译之后的信息了，文件中的字符在我们看来只是一行一行字符，其实是划分格式的。我们来看一下是如何划分的。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Class文件的结构，是一个结构体，有以下元素，描述如下：</p><pre><code>ClassFile {    u4  magic;  //魔数    u2  minor_version;  //Java的次版本号    u2  major_version;  //Java的主版本号    u2  constant_pool_count;  //常量池的长度    cp_info  constant_pool[constant_pool_count];  //常量池数组    u2  access_flags;  //类访问标志    u2  this_class;  //类名索引    u2  super_class;  //父类名索引    u2  interface_count;  //实现的接口的数量    u2  interfaces[interface_count];  //接口数组    u2  fields_count;  //字段数量    field_info  fields[fields_count];  //字段数组    u2  methods_count;  //方法数量    method_info  methods[methods_count];  //方法数组    u2  attributes_count;  //属性数量    attribute_info  attributes[attributes_count];  //属性数组}</code></pre><p>左边u2,u4都是表示字节的长度，u2是两字节，u4是四字节。右边是元素的名称。<br>Class文件就是由以上元素，一个紧挨一个组成的。总体的结构还是不复杂的，开头的三个值，<code>magic，minor_version，major_version</code>和中间的<code>access_flags，this_class，super_class</code>，他们是固定的位置，固定的字节长度。其他的数量不一定的值，都是一个长度，然后后面就是紧跟着该长度的数组，存储着该组值。数组结构通常都有下一级的子结构。<br>我把字节文件按照上面的元素格式，以不同的颜色划分了出来，请大家看下结构图：<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/ob2yf2.jpg" alt="class-simple.png"><br>看图非常的一目了然，读两遍书，不如看一遍图啊。<br>连续的相同颜色的格子，是同一种元素的值。元素之间是紧紧的排列在一起，大家可以看到结构非常的紧凑，节省空间。看不清的同学可以下载下来，放大一下看。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-magic-魔数"><a href="#1-magic-魔数" class="headerlink" title="1. magic  魔数"></a>1. magic  魔数</h4><p>我们知道有时候通过后缀识别文件是不准确的，因为很容易就改掉后缀。所以很多文件格式，在文件的开头写上几个固定的值，为了识别方便该种格式。比如PDF文件的开头是“%PDF”，这个固定的值，就叫魔数，其实就是个标识。class文件的魔数就是“CA FE BA BE”，JVM读取开头的四个字节，如果是这个值，那么就认为这个文件是个class。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/2PeYHT.jpg" alt="magic.jpg"></p><h4 id="2-version-版本号"><a href="#2-version-版本号" class="headerlink" title="2. version 版本号"></a>2. version 版本号</h4><p>魔数之后，是版本号，大家可以看到，我们有两部分的版本号。第一个版本号就是次版本号，第二个是主版本号。比如52.0，52是主版本号，0是次版本号。这个版本是为了让JVM识别编译这个clas文件的Java版本，比如Java SE8，对应的版本号是52.0，Java SE7 是51.0，Java SE6 是50.0。如果一个最高只支持Java SE7版本的JVM，读取到一个52.0，那么它可能是执行不了这个class的，以为它是Java SE8编译出来的，可能用了JavaSE8的新特性。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/73qnZW.jpg" alt="version.jpg"></p><h4 id="3-constant-pool-常量池"><a href="#3-constant-pool-常量池" class="headerlink" title="3. constant_pool 常量池"></a>3. constant_pool 常量池</h4><p>常量池占用了class中非常多的空间，存放着非常多的信息，包括数字，字符串，类和接口的名字，字段和方法的名字等等。上来先是常量池的数量，也就是常量池数组的长度。后面紧跟着就是数组的内容，非常长，结构也不太一样。大家可以仔细看看附录中的详细图，太大了，在这就不截图了。<br>常量池中元素的子结构虽然有非常多的种类，但是都差不多的。首先是tag，tag的值表示这个元素是一个什么类型，也就是一个什么数据结构，然后JVM就可以根据这个结构来解析数据了。一般的XXX_index就是一个索引，length就是一个长度，bytes中是该元素存储的值。结构非常多，我们后面单独一篇文章介绍下这里。</p><h4 id="4-access-flags-类访问标志"><a href="#4-access-flags-类访问标志" class="headerlink" title="4. access_flags 类访问标志"></a>4. access_flags 类访问标志</h4><p><code>access_flags</code>保存的信息是，该类的访问标志，比如是public还是private，是个接口还是个类，或者枚举，等等。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/bU17en.jpg" alt="access_flags.jpg"><br>此处<code>access_flags</code>的值是0x0021，代表什么意思呢？我们需要看个表格：</p><table><thead><tr><th>名称</th><th>值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td style="text-align:right">public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td style="text-align:right">final修饰符</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td style="text-align:right">使用invokespecial字节码指令，在JDK1.2之后添加</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td style="text-align:right">接口</td></tr></tbody></table><p>还有好几种类型，我们就先看这些。我们的值是0x0021，好像没有这个值对应的类型。其实是，0x0020 加上 0x0001，也就是说0x0021表示<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>。也就是说，这是个public访问级别的类。</p><h4 id="5-this-class-类名索引"><a href="#5-this-class-类名索引" class="headerlink" title="5. this_class 类名索引"></a>5. this_class 类名索引</h4><p><code>this_class</code>元素保存的是类的全限定类名，即包路径加类名。为什么还有个索引呢？因为这个地方保存的不是具体的全限定类名的字符串，是一个索引值。这个索引是常量池的索引，也就是说，其实真正的全限定类名字符串是在常量池存着呢。我们在附录的详细表中找一下这个值，找到第39行数据的最后，是<code>this_class</code>的位置。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/wiIKrk.jpg" alt="this_class"><br>它的值是0x000c，是十进制的12对吧？我们找常量池中的索引是12的值，在第4行最后。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/LHZuYK.jpg" alt="index_12.jpg"><br>很奇怪，这个地方比不是我们说的全限定类名字符串，是一个叫<code>name_index</code>的索引。其实这个位置存放的数据，是有一个子结构的，它由tag和<code>name_index</code>组成。tag的值是7，这个值7代表了一种数据结构，就是<code>CONSTANT_Class_info</code>，这个类型保存的值是类或者接口的符号引用。又是一个引用，也就是索引。从表上我们可以知道，这个索引的值是49，OK，我们再从常量池找索引49的值。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/8SpUaI.jpg" alt="index_49.jpg"><br>在第26和27行上，我们终于找到了类的全限定名称。</p><h4 id="6-super-class-父类名索引"><a href="#6-super-class-父类名索引" class="headerlink" title="6. super_class 父类名索引"></a>6. super_class 父类名索引</h4><p><code>super_class</code>跟<code>this_class</code>是一样的，不过这里保存的是类的父类全限定名称而已。大家可以自己找一下看看。不过需要注意的是，如果没有明确指定某个类的父类，在Java中默认父类都是java.lang.Object，而java.lang.Object本身是没有父类的，所以如果是Object类，它的<code>super_class</code>值就是0。</p><h4 id="7-interfaces-接口池"><a href="#7-interfaces-接口池" class="headerlink" title="7. interfaces  接口池"></a>7. interfaces  接口池</h4><p>接着就是接口索引表或者说是接口池了，这里保存类实现的接口。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/Nc7AxX.jpg" alt="interfaces.jpg"><br>因为我们的类没有实现接口，所以它的长度是0，后面的数组自然也就省略了。</p><h4 id="8-fields-字段池"><a href="#8-fields-字段池" class="headerlink" title="8. fields 字段池"></a>8. fields 字段池</h4><p><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/70w2DW.jpg" alt="fields.jpg"><br>接着是我们的字段信息。从 <code>fields_count</code>的值我们可以知道有4个字段，这跟我们在代码中的字段数量是一致的。然后紧接着就是字段数组了。字段数组中的元素是有数据结构的。如下：</p><pre><code>field_info {  u2  access_flags;  //变量的访问标识符  u2  name_index;  //名称索引  u2  descriptor_index;  //类型信息索引  u2  attributes_count;  //自定义属性长度  attribute_info  attributes[attributes_count];  //自定义属性池}</code></pre><p><code>name_index</code>中存的就是字段名字的索引，老规矩大家自己找一下。<code>access_flags</code>是变量的访问标识符，<code>descriptor_index</code>保存的是变量的类型信息。最后剩下的属性，为什么有了类的属性池还会在这里有个字段下的属性池呢？这个字段下的属性池是留给JVM来自定义拓展的，各个JVM实现可能会不一样，JVM遇到识别不了的属性会自动跳过。</p><h4 id="9-methods-方法池"><a href="#9-methods-方法池" class="headerlink" title="9. methods 方法池"></a>9. methods 方法池</h4><p>大家可以看到，在附录详细大图中，方法池没有展开详细的结构，这是因为这里太复杂了，展开图不太好画，我太懒了，所以没画，哈哈哈哈。依然是上来就是一个长度，3个方法，后面跟着一个数组。有人要问了，不对啊，怎么是3个方法，我们只写了2个。那是因为还有个类的默认构造方法，忘了吧，哈哈。后面有机会我们详细分析方法池的结构。</p><h4 id="10-attributes-属性池"><a href="#10-attributes-属性池" class="headerlink" title="10. attributes 属性池"></a>10. attributes 属性池</h4><p>属性池这个地方，跟常量池一样，保存了很多信息，不过我们这个类中的属性信息较少。属性也有很多的子结构，而且不同的JVM实现还可能会有自己的属性值，这里我们后面有机会单独说一下，大家现在知道即可。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>最后，附上一张非常详细的大图，我在图中画出了更详细的结构，包括常量池中子元素的结构，每个字节对应的值是什么等等，非常详细，也耗费了我很多时间，希望对大家有用。大家可以下载下来，经常看一看。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/03/31/1qnzA5Qt4rFVLKM.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
            <tag> 字节码 </tag>
            
            <tag> 分析图 </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Jar 是怎么启动的--FatJar启动流程分析</title>
      <link href="/2019/09/29/Spring-Boot-Jar-start-step/"/>
      <url>/2019/09/29/Spring-Boot-Jar-start-step/</url>
      
        <content type="html"><![CDATA[<p>首先搭建一个Spring Boot工程，非常简单，在<a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a>上快速生成一个项目就可以了，使用Java语言，其他的可以根据需要自己选择。<br>如果你没有什么特殊需要，可以参照我下面的设置。<br><img src="https://i.loli.net/2019/10/29/hjXWMCVKm7cT3qO.png" alt="initializr.png"><br>点击Generate之后，下载生成的工程。<br>在工程目录下，执行<code>mvn package -Dmaven.test.skip=true</code>命令，打包。<br><img src="https://i.loli.net/2019/10/29/pWK9iku4hdEmBcq.png" alt="jar-file.png"><br>在target目录下，会生成一个jar，名字是demo-0.0.1-SNAPSHOT.jar，这就是我们要分析的jar，如下图:</p><p>然后我们解压这个jar，看看跟普通的jar有什么区别。<br>解压之后，目录是这样的，只展开了2级目录(详细的请看附录):</p><pre><code>├── BOOT-INF│   ├── classes│   └── lib├── META-INF│   ├── MANIFEST.MF│   └── maven└── org    └── springframework</code></pre><p>再看一个普通的jar，也就是非Spring Boot的jar是什么样子的</p><pre><code>├── META-INF│   ├── MANIFEST.MF│   └── maven└── com    └── guofeng</code></pre><p>大家对比一下，Spring Boot的jar只比普通的jar多出了一个BOOT-INF目录，其他的东西在结构上是一样的。也就是说，首先Spring Boot的jar肯定是兼容普通的jar，普通jar有的东西，它都有，这样，它才能用<code>java -jar</code>运行。普通的jar，依赖都是在外部的，Spring Boot的fatjar，依赖都在Jar包内，还有就是把工程代码换了下位置。</p><p>我们知道在jar运行之前，会首先从MANIFEST.MF文件中，查找jar的相关信息。我们看看这个文件里的内容</p><pre><code>Manifest-Version: 1.0Created-By: Maven Archiver 3.4.0Build-Jdk-Spec: 12Implementation-Title: demoImplementation-Version: 0.0.1-SNAPSHOTMain-Class: org.springframework.boot.loader.JarLauncherStart-Class: com.example.demo.DemoApplicationSpring-Boot-Version: 2.2.0.M6Spring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/</code></pre><p>上面有几个参数是需要我们关注的：</p><ol><li>Main-Class<br>这个是jar的入口函数main方法的类路径，这里可以看到，这个是spring的方法，不是我们工程中写的方法。</li><li>Start-Class<br>这个参数是 Spring Boot定义的，可以看到，这个类是我们工程里的了。这个是我们工程的main方法的类路径。</li><li>Spring-Boot-Classes<br>这个很明显，是工程代码在jar中的路径</li><li>Spring-Boot-Lib<br>这个是工程中引入的依赖jar。Spring Boot把工程依赖的所有jar都打包在了项目的jar中，这就是为什么它是个fatjar。</li></ol><p>好的， 我们跟踪着普通jar启动的脚步，先看看jar的入口函数org.springframework.boot.loader.JarLauncher。<br>这个类在工程中是找不到的，因为是jar启动需要的，在打包阶段由maven打进去的，工程是不需要的。<br>它在包spring-boot-loader中，GAV是:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-loader&lt;/artifactId&gt;    &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>你可以在<a href="https://github.com/spring-projects/spring-boot/blob/8a9c60a29a81a0abdc145cf85c037daae8defbf0/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/JarLauncher.java" target="_blank" rel="noopener">JarLauncher</a>中找到这个类的源代码。<br>我们看下它的main方法:</p><pre><code>public static void main(String[] args) throws Exception{        new JarLauncher().launch(args);    }</code></pre><p>非常的简单，它调用了<code>JarLauncher</code>的<code>launch</code>方法，并且把参数都传递进去了。但是在<code>JarLauncher</code>中并没有<code>launch</code>这个方法，这个方法是<code>JarLauncher</code>的祖父类<code>Launcher</code>的方法，继承关系是这样的<code>JarLauncher---&gt;ExecutableArchiveLauncher---&gt;Launcher</code>。<br>我们看一下<code>launch</code>方法的实现:</p><pre><code>protected void launch(String[] args) throws Exception {        JarFile.registerUrlProtocolHandler();        ClassLoader classLoader = createClassLoader(getClassPathArchives());        launch(args, getMainClass(), classLoader);    }</code></pre><p>这是一个<code>protected</code>方法，只能在它的子类中使用。<br>首先看第一句代码:<code>JarFile.registerUrlProtocolHandler();</code>，它的实现是:</p><pre><code>public static void registerUrlProtocolHandler() {        //PROTOCOL_HANDLER = &quot;java.protocol.handler.pkgs&quot;;        String handlers = System.getProperty(PROTOCOL_HANDLER, &quot;&quot;);        //HANDLERS_PACKAGE = &quot;org.springframework.boot.loader&quot;        System.setProperty(PROTOCOL_HANDLER, (&quot;&quot;.equals(handlers) ? HANDLERS_PACKAGE : handlers + &quot;|&quot; + HANDLERS_PACKAGE));        resetCachedUrlHandlers();    }</code></pre><p>这几句代码非常简单，就是重新设置了一个属性值，叫做<code>java.protocol.handler.pkgs</code>。<br>那么这个属性值是干什么用的呢，从属性名字上我们能大体猜测一下，跟protocol有关，也就是协议。什么是协议？http，https这是最常见的协议吧？对的，这个属性值是存放的一个路径，这个路径下面对应的是各种协议的处理逻辑。除了http和https，还有jar，file，ftp等等协议。这个属性值默认是<code>sun.net.www.protocol.jar.Handler</code>，这是Java的默认实现，大家可以去这个路径下看一下。</p><p>Spring Boot重新将这个路径设置了一下，添加了<code>org.springframework.boot.loader</code>路径，这个路径下有Spring Boot提供的Jar协议处理逻辑，也就是覆盖了原来的Jar处理逻辑。Spring Boot的Jar跟普通的Jar是有区别的，依赖是打包在Jar中的，引导类是Spring提供的实现，但是我们最后的目的肯定是启动我们自己的工程。所以在这个地方覆盖了默认的Jar启动逻辑，按照Spring的Jar启动逻辑来走，其目的就是自定义Jar包依赖的查找逻辑，从Jar内部找依赖，最终启动用户的工程。</p><p>我们再看第二句代码：</p><pre><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code></pre><p>简略一看，大家都能懂的，是创建了一个ClassLoader。我们仔细研究下<code>getClassPathArchives</code>方法，它的实现是：</p><pre><code>@Override    protected List&lt;Archive&gt; getClassPathArchives() throws Exception {        List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(                this.archive.getNestedArchives(this::isNestedArchive));        postProcessClassPathArchives(archives);        return archives;    }</code></pre><p>最主要就是方法的第一句代码，它是获取用户工程代码和依赖的。拆分一下，我们先看<code>isNestedArchive</code>方法，它在JarLauncher和WarLauncher中，一共两种实现，我们看下JarLauncher中的实现：</p><pre><code>@Override    protected boolean isNestedArchive(Archive.Entry entry) {        if (entry.isDirectory()) {            return entry.getName().equals(BOOT_INF_CLASSES);        }        return entry.getName().startsWith(BOOT_INF_LIB);    }</code></pre><p>这个方法是一个过滤器，它把<code>BOOT-INF/classes/</code>和<code>BOOT-INF/lib/</code>中的类和jar过滤了出来。然后再回到<code>getClassPathArchives</code>方法中，在<code>getNestedArchives</code>方法中：</p><pre><code>@Override    public List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException {        List&lt;Archive&gt; nestedArchives = new ArrayList&lt;&gt;();        for (Entry entry : this) {            if (filter.matches(entry)) {                nestedArchives.add(getNestedArchive(entry));            }        }        return Collections.unmodifiableList(nestedArchives);    }</code></pre><p>在这里，把所有符合过滤条件的文件，都放到了nestedArchives中，然后返回给调用者。<br>现在，在代码<code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code>中，我们就好理解了，<code>getClassPathArchives</code>方法获取到了工程代码和工程的依赖jar，然后根据这些东西，创建了<code>ClassLoader</code>。</p><p>好的，还有最后一句代码:</p><pre><code>launch(args, getMainClass(), classLoader);</code></pre><p>这个毫无疑问，就是最后的启动过程了。同样的，先分析参数<code>getMainClass</code>方法：</p><pre><code>@Override    protected String getMainClass() throws Exception {        Manifest manifest = this.archive.getManifest();        String mainClass = null;        if (manifest != null) {            mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);        }        if (mainClass == null) {            throw new IllegalStateException(                    &quot;No &#39;Start-Class&#39; manifest entry specified in &quot; + this);        }        return mainClass;    }</code></pre><p>首先代码上来是获取Manifest，这个文件对应的就是Jar包中的MANIFEST.MF文件，我们说过，这个文件中定义了Jar包的信息。然后，注意后面的代码，从文件中获取了<code>Start-Class</code>的值。我们在看这个文件的时候，<code>Start-Class</code>是定义了我们工程的启动类，对吧？终于，这个地方要运行我们自己的main方法了，现在我们拿到了用户的main方法的所在类。</p><p>然后看launch方法，是怎么启动的：</p><pre><code>protected void launch(String[] args, String mainClass, ClassLoader classLoader)            throws Exception {        Thread.currentThread().setContextClassLoader(classLoader);        createMainMethodRunner(mainClass, args, classLoader).run();    }</code></pre><p>首先把我们刚刚创建的classLoader放到了当前线程中。这个classLoader中带着我们工程代码和工程依赖，没忘吧？OK。<br>继续继续，敲黑板，重点来了，createMainMethodRunner方法的实现如下：</p><pre><code>public void run() throws Exception {        Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()                .loadClass(this.mainClassName);        Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);        mainMethod.invoke(null, new Object[] { this.args });    }</code></pre><p>通过我们创建的classLoader，去找<code>Start-Class</code>定义的class类文件。在这个class文件中，找main方法，然后调用这个main方法。<br>咚咚咚咚，Jar启动流程到这里就结束了，后面就是Spring Boot应用的启动过程了。<br>到这里，Spring Boot Jar启动流程就分析完了，是不是非常简洁和条理清晰，很巧妙的方法，佩服这些大佬。<br>大家可以下载Spring Boot的源代码，然后再仔细的回味一下。</p><p>附录：</p><ol><li><p>Spring Boot Jar解压之后的文件目录树</p><pre><code>├── BOOT-INF│   ├── classes│   │   ├── application.properties│   │   └── com│   │       └── example│   │           └── demo│   │               └── DemoApplication.class│   └── lib│       ├── classmate-1.5.0.jar│       ├── hibernate-validator-6.0.17.Final.jar│       ├── jackson-annotations-2.9.0.jar│       ├── jackson-core-2.9.9.jar│       ├── jackson-databind-2.9.9.3.jar│       ├── jackson-datatype-jdk8-2.9.9.jar│       ├── jackson-datatype-jsr310-2.9.9.jar│       ├── jackson-module-parameter-names-2.9.9.jar│       ├── jakarta.annotation-api-1.3.5.jar│       ├── jakarta.validation-api-2.0.1.jar│       ├── jboss-logging-3.4.1.Final.jar│       ├── jul-to-slf4j-1.7.28.jar│       ├── log4j-api-2.12.1.jar│       ├── log4j-to-slf4j-2.12.1.jar│       ├── logback-classic-1.2.3.jar│       ├── logback-core-1.2.3.jar│       ├── slf4j-api-1.7.28.jar│       ├── snakeyaml-1.25.jar│       ├── spring-aop-5.2.0.RC2.jar│       ├── spring-beans-5.2.0.RC2.jar│       ├── spring-boot-2.2.0.M6.jar│       ├── spring-boot-autoconfigure-2.2.0.M6.jar│       ├── spring-boot-starter-2.2.0.M6.jar│       ├── spring-boot-starter-json-2.2.0.M6.jar│       ├── spring-boot-starter-logging-2.2.0.M6.jar│       ├── spring-boot-starter-tomcat-2.2.0.M6.jar│       ├── spring-boot-starter-validation-2.2.0.M6.jar│       ├── spring-boot-starter-web-2.2.0.M6.jar│       ├── spring-context-5.2.0.RC2.jar│       ├── spring-core-5.2.0.RC2.jar│       ├── spring-expression-5.2.0.RC2.jar│       ├── spring-jcl-5.2.0.RC2.jar│       ├── spring-test-5.2.0.RC2.jar│       ├── spring-web-5.2.0.RC2.jar│       ├── spring-webmvc-5.2.0.RC2.jar│       ├── tomcat-embed-core-9.0.24.jar│       ├── tomcat-embed-el-9.0.24.jar│       └── tomcat-embed-websocket-9.0.24.jar├── META-INF│   ├── MANIFEST.MF│   └── maven│       └── com.example│           └── demo│               ├── pom.properties│               └── pom.xml└── org └── springframework     └── boot         └── loader             ├── ExecutableArchiveLauncher.class             ├── JarLauncher.class             ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class             ├── LaunchedURLClassLoader.class             ├── Launcher.class             ├── MainMethodRunner.class             ├── PropertiesLauncher$1.class             ├── PropertiesLauncher$ArchiveEntryFilter.class             ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class             ├── PropertiesLauncher.class             ├── WarLauncher.class             ├── archive             │   ├── Archive$Entry.class             │   ├── Archive$EntryFilter.class             │   ├── Archive.class             │   ├── ExplodedArchive$1.class             │   ├── ExplodedArchive$FileEntry.class             │   ├── ExplodedArchive$FileEntryIterator$EntryComparator.class             │   ├── ExplodedArchive$FileEntryIterator.class             │   ├── ExplodedArchive.class             │   ├── JarFileArchive$EntryIterator.class             │   ├── JarFileArchive$JarFileEntry.class             │   └── JarFileArchive.class             ├── data             │   ├── RandomAccessData.class             │   ├── RandomAccessDataFile$1.class             │   ├── RandomAccessDataFile$DataInputStream.class             │   ├── RandomAccessDataFile$FileAccess.class             │   └── RandomAccessDataFile.class             ├── jar             │   ├── AsciiBytes.class             │   ├── Bytes.class             │   ├── CentralDirectoryEndRecord.class             │   ├── CentralDirectoryFileHeader.class             │   ├── CentralDirectoryParser.class             │   ├── CentralDirectoryVisitor.class             │   ├── FileHeader.class             │   ├── Handler.class             │   ├── JarEntry.class             │   ├── JarEntryFilter.class             │   ├── JarFile$1.class             │   ├── JarFile$2.class             │   ├── JarFile$JarFileType.class             │   ├── JarFile.class             │   ├── JarFileEntries$1.class             │   ├── JarFileEntries$EntryIterator.class             │   ├── JarFileEntries.class             │   ├── JarURLConnection$1.class             │   ├── JarURLConnection$2.class             │   ├── JarURLConnection$CloseAction.class             │   ├── JarURLConnection$JarEntryName.class             │   ├── JarURLConnection.class             │   ├── StringSequence.class             │   └── ZipInflaterInputStream.class             └── util                 └── SystemPropertyUtils.class</code></pre></li><li><p>普通Jar解压之后的文件树：</p><pre><code>├── META-INF│   ├── MANIFEST.MF│   └── maven│       └── com.guofeng│           └── first-spring-boot│               ├── pom.properties│               └── pom.xml└── com └── guofeng     └── think         └── App.class</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring-Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Boot </tag>
            
            <tag> Jar </tag>
            
            <tag> 启动 </tag>
            
            <tag> FatJar </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven的mvn dependency依赖分析和常用命令介绍</title>
      <link href="/2019/09/28/mvn-dependency/"/>
      <url>/2019/09/28/mvn-dependency/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在项目开发过程中，我们经常会有分析项目依赖的需要，查找jar依赖路径，查找jar冲突等等。这时候，dependency命令会非常的有用，在此我们介绍下关于maven的dependency命令的一些用法。</p></blockquote><h2 id="1-mvn-dependency-list-—-列出项目的所有jar包"><a href="#1-mvn-dependency-list-—-列出项目的所有jar包" class="headerlink" title="1. mvn dependency:list —- 列出项目的所有jar包"></a>1. <code>mvn dependency:list</code> —- 列出项目的所有jar包</h2><p><code>mvn dependency:list -Dverbose</code><br>该命令可以列出项目依赖的所有jar包，-Dverbose参数会把被忽略的jar，即相同jar包的不同版本引入也列出来。<br>输出示例：</p><pre><code>[INFO]    org.springframework:spring-aop:jar:5.0.6.RELEASE:compile[INFO]    org.hibernate.validator:hibernate-validator:jar:6.0.9.Final:compile[INFO]    com.fasterxml.jackson.core:jackson-core:jar:2.9.5:compile[INFO]    com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.5:compile[INFO]    org.springframework:spring-expression:jar:5.0.6.RELEASE:compile[INFO]    org.springframework.boot:spring-boot-starter:jar:2.0.2.RELEASE:compile[INFO]    org.springframework.boot:spring-boot-starter-logging:jar:2.0.2.RELEASE:compile[INFO]    org.yaml:snakeyaml:jar:1.19:runtime[INFO]    org.springframework.boot:spring-boot:jar:2.0.2.RELEASE:compile[INFO]    junit:junit:jar:3.8.1:test</code></pre><h2 id="2-mvn-dependency-tree-—-列出项目的包依赖树"><a href="#2-mvn-dependency-tree-—-列出项目的包依赖树" class="headerlink" title="2. mvn dependency:tree —- 列出项目的包依赖树"></a>2. <code>mvn dependency:tree</code> —- 列出项目的包依赖树</h2><p><code>mvn dependency:tree -Dverbose</code><br>这个命令跟上一个命令的区别就是，这个命令的依赖，输出来是个树，更方便看依赖关系。<br>输出示例：</p><pre><code>[INFO] \- org.springframework.boot:spring-boot-starter-web:jar:2.0.2.RELEASE:compile[INFO]    +- org.springframework.boot:spring-boot-starter:jar:2.0.2.RELEASE:compile[INFO]    |  \- org.springframework:spring-core:jar:5.0.6.RELEASE:compile[INFO]    |     \- org.springframework:spring-jcl:jar:5.0.6.RELEASE:compile[INFO]    +- org.springframework:spring-web:jar:5.0.6.RELEASE:compile[INFO]    |  \- org.springframework:spring-beans:jar:5.0.6.RELEASE:compile[INFO]    \- org.springframework:spring-webmvc:jar:5.0.6.RELEASE:compile[INFO]       +- org.springframework:spring-aop:jar:5.0.6.RELEASE:compile[INFO]       +- org.springframework:spring-context:jar:5.0.6.RELEASE:compile[INFO]       \- org.springframework:spring-expression:jar:5.0.6.RELEASE:compile</code></pre><p><code>dependency:tree</code>有几个比较重要的参数，非常有用:</p><ul><li>includes <ul><li>说明：该参数可以列出指定要求的jar，其他的忽略</li><li>示例：<code>-Dincludes=velocity:velocity</code>，只列出velocity的依赖关系</li><li>参数值：<code>[groupId]:[artifactId]:[type]:[version]</code>，参数格式就是这样的，没有的值可以留空，举例<code>-Dincludes=:spring-aop</code>，<code>-Dincludes=:::5.0.6.RELEASE</code>，<code>-Dincludes=org.springframework</code></li><li>通配符：在参数中可以使用通配符，例如<code>org.apache.*</code>, <code>:::*-SNAPSHOT</code></li><li>多个参数值：参数后面可以跟多个参数值，以英文逗号分隔，举例<code>-Dincludes=org.apache.maven*,org.codehaus.plexus</code></li></ul></li><li>excludes<ul><li>说明：该参数的用法跟<code>includes</code>是一样的，不过这个参数的作用是排除指定的jar</li></ul></li></ul><h4 id="示例-查看包冲突"><a href="#示例-查看包冲突" class="headerlink" title="示例:查看包冲突"></a>示例:查看包冲突</h4><p>比如我们查看一下<code>commons-collections</code>包的冲突<br>命令:<br><code>mvn dependency:tree -Dverbose -Dincludes=commons-collections</code><br>输出:</p><pre><code>[INFO] [dependency:tree][INFO] org.apache.maven.plugins:maven-dependency-plugin:maven-plugin:2.0-alpha-5-SNAPSHOT[INFO] +- org.apache.maven.reporting:maven-reporting-impl:jar:2.0.4:compile[INFO] |  \- commons-validator:commons-validator:jar:1.2.0:compile[INFO] |     \- commons-digester:commons-digester:jar:1.6:compile[INFO] |        \- (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 2.0)[INFO] \- org.apache.maven.doxia:doxia-site-renderer:jar:1.0-alpha-8:compile[INFO]    \- org.codehaus.plexus:plexus-velocity:jar:1.1.3:compile[INFO]       \- commons-collections:commons-collections:jar:2.0:compile</code></pre><p>我们可以看到，2.1版本的jar被忽略掉了，因为maven是根据路径最近原则来解析依赖，2.0版本路径更短，所以2.0版本被引入，2.1版本路径比2.0要长，所以被忽略。<br>使用这个命令可以轻松的查看包的引入路径，包的冲突情况。<br>此处一定不要省略<code>-Dverbose</code>参数，要不然是不会显示被忽略的包</p><h2 id="3-dependency-analyze-only-—-分析依赖"><a href="#3-dependency-analyze-only-—-分析依赖" class="headerlink" title="3. dependency:analyze-only —- 分析依赖"></a>3. <code>dependency:analyze-only</code> —- 分析依赖</h2><p><code>dependency:analyze-only</code>命令可以分析整个项目，并且找出项目中依赖有如下情况的：</p><ul><li>声明了并且使用了的依赖</li><li>没有声明但是使用了的依赖</li><li>声明了但是没有使用的依赖</li></ul><p>输出示例：</p><pre><code>[INFO] Used declared dependencies found:[INFO]    cn.hutool:hutool-all:jar:4.3.1:compile[INFO]    com.google.guava:guava:jar:27.0.1-jre:compile[WARNING] Used undeclared dependencies found:[WARNING]    org.slf4j:slf4j-api:jar:1.7.25:compile[WARNING]    org.springframework:spring-context:jar:4.3.22.RELEASE:compile[WARNING]    org.springframework.boot:spring-boot-autoconfigure:jar:1.5.19.RELEASE:compile[WARNING]    org.springframework.boot:spring-boot:jar:1.5.19.RELEASE:compile[WARNING]    org.springframework:spring-beans:jar:4.3.22.RELEASE:compile[WARNING]    junit:junit:jar:4.12:test[WARNING] Unused declared dependencies found:[WARNING]    org.springframework.boot:spring-boot-starter-test:jar:1.5.19.RELEASE:test[WARNING]    com.h2database:h2:jar:1.4.197:test[WARNING]    org.springframework.boot:spring-boot-starter:jar:1.5.19.RELEASE:compile[WARNING]    com.fasterxml.jackson.core:jackson-databind:jar:2.8.11.3:compile[WARNING]    org.projectlombok:lombok:jar:1.16.22:compile[WARNING]    com.alibaba:fastjson:jar:1.2.55:compile</code></pre><p>需要注意的是，如果你要查看声明了并且使用了的依赖，必须加上参数<code>-Dverbose</code>。</p><h2 id="4-dependency-analyze-duplicate-—-分析-and"><a href="#4-dependency-analyze-duplicate-—-分析-and" class="headerlink" title="4. dependency:analyze-duplicate —- 分析 and "></a>4. <code>dependency:analyze-duplicate</code> —- 分析<dependencies> and <dependencymanagement></dependencymanagement></dependencies></h2><p>这个命令会查找<code>&lt;dependencies/&gt; 和 &lt;dependencyManagement/&gt;</code>中重复声明的依赖</p><h2 id="5-dependency-list-repositories-—-列出所有的远程repositories"><a href="#5-dependency-list-repositories-—-列出所有的远程repositories" class="headerlink" title="5. dependency:list-repositories —- 列出所有的远程repositories"></a>5. <code>dependency:list-repositories</code> —- 列出所有的远程repositories</h2><p>命令:<br><code>mvn dependency:list-repositories</code></p><p>输出:</p><pre><code>[INFO]        id: sonatype-nexus-snapshots      url: https://oss.sonatype.org/content/repositories/snapshots   layout: defaultsnapshots: [enabled =&gt; true, update =&gt; daily] releases: [enabled =&gt; false, update =&gt; daily][INFO]        id: apache.snapshots      url: https://repository.apache.org/snapshots   layout: defaultsnapshots: [enabled =&gt; true, update =&gt; daily] releases: [enabled =&gt; false, update =&gt; daily][INFO]        id: central      url: https://repo.maven.apache.org/maven2   layout: defaultsnapshots: [enabled =&gt; false, update =&gt; daily] releases: [enabled =&gt; true, update =&gt; daily]</code></pre><h2 id="6-dependency-purge-local-repository-—-清理本地repository"><a href="#6-dependency-purge-local-repository-—-清理本地repository" class="headerlink" title="6. dependency:purge-local-repository —- 清理本地repository"></a>6. <code>dependency:purge-local-repository</code> —- 清理本地repository</h2><p>这个命令的会首先解析整个项目的依赖，然后从本地repository中清理这些依赖，重新从远程repository下载。</p><ul><li>直接依赖<br>有一点要说清楚，这个命令默认的对所有的依赖项进行操作。所以它会在清除操作之前，下载某些缺失的依赖来收集完整的依赖树信息。为了避免这些预下载的操作，你可以设置参数<code>-DactTransitively=false</code>，仅对项目的直接依赖进行操作。</li><li>指定/排除依赖<br>你也可以有针对性的只操作某些包，需要添加参数<code>-Dincludes</code>，明确的声明包，这个是可以传多个值的，用英文逗号分隔，举例:<code>dependency:purge-local-repository -Dincludes=org.slf4j:slf4j-api,org.slf4j:log4j-over-slf4j</code>。<code>-Dexcludes</code>也是一样的道理，只不过是排除某些依赖。</li><li>自定义清理<br>如果你想清理不在本项目中的依赖，也可以使用这个，不过参数是不一样的。<code>mvn dependency:purge-local-repository -DmanualIncludes=org.apache:apache</code>，参数<code>-DmanualInclude</code>可以让你清理不在本项目中的依赖，但是不会重新解析依赖了，因为本项目不需要这些依赖。这个对清理parent pom，导入的pom，maven插件非常有用</li></ul>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> dependency </tag>
            
            <tag> mvn </tag>
            
            <tag> 依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-17-Sail命令之rm&amp;shell</title>
      <link href="/2019/08/22/SailDocument-17-rm/"/>
      <url>/2019/08/22/SailDocument-17-rm/</url>
      
        <content type="html"><![CDATA[<h1 id="17-Sail命令之rm"><a href="#17-Sail命令之rm" class="headerlink" title="17-Sail命令之rm"></a>17-Sail命令之rm</h1><pre><code>Usage: sail rm [flags] &lt;repo&gt;Remove a sail container from the system.This command allows for removing a single containeror all of the containers on a system with the -all flag.sail rm flags:    --all    Remove all sail containers.(false)</code></pre><p><code>rm</code>可以删除容器，<code>--all</code>参数可以删除所有容器。</p><h1 id="18-Sail命令之shell"><a href="#18-Sail命令之shell" class="headerlink" title="18-Sail命令之shell"></a>18-Sail命令之shell</h1><pre><code>Usage: sail shell &lt;repo&gt;shell drops you into the default shell of a repo container.</code></pre><p><code>shell</code>命令可以让你进入到容器的shell中。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-16-Sail命令之ls</title>
      <link href="/2019/08/21/SailDocument-16-ls/"/>
      <url>/2019/08/21/SailDocument-16-ls/</url>
      
        <content type="html"><![CDATA[<h1 id="16-Sail命令之ls"><a href="#16-Sail命令之ls" class="headerlink" title="16-Sail命令之ls"></a>16-Sail命令之ls</h1><pre><code>Usage: sail lsLists all containers with the com.coder.sail label.sail ls flags:    --all    Show stopped container.(false)</code></pre><p><code>ls</code> 命令会列出所有的容器，但是容器标签是com.coder.sail库的标签</p><p>示例输出:</p><pre><code>name                 hat   url                     statuscdr/sail                   http://127.0.0.1:8828   Up About an hourcdr/sshcode                http://127.0.0.1:8130   Up About an hourcdr/m                      http://127.0.0.1:8754   Up About an hourcdr/code-server            http://127.0.0.1:8828   Up About an hourcdr/sail-tmp-kEG58         http://127.0.0.1:8130   Up About an hour</code></pre>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-15-Sail命令之edit</title>
      <link href="/2019/08/20/SailDocument-15-edit/"/>
      <url>/2019/08/20/SailDocument-15-edit/</url>
      
        <content type="html"><![CDATA[<h1 id="15-Sail命令之edit"><a href="#15-Sail命令之edit" class="headerlink" title="15-Sail命令之edit"></a>15-Sail命令之edit</h1><pre><code>Usage: sail edit [flags] &lt;repo&gt;# 这个命令让你在容器运行中就可以编辑项目的环境。根据你写的命令参数，``edit``命令会用编辑器打开相应的Dockerfile，编辑器你可以用``EDITOR``环境变量来指定。编辑器关闭之后，环境将会重新构建，并且在最短的时间内重新运行。# 如果没有写参数，就会在编辑器中打开项目的Dockerfile，如果参数是``-hat``，就会打开项目关联的hat的Dockerfile。如果参数是``-new-hat``，项目将会使用新的hat。# VS Code用户可以通过在编辑器中的``.sail/Dockerfile``文件来编辑环境。编辑完成点击&#39;rebuild&#39;按钮之后，VS Code会重新构建容器。sail edit flags:    --hat    Edit the hat associated with this project.    (false)    --new-hat    Path to new hat.</code></pre><p><code>edit</code>命令可以让你编辑开发环境。VS Code用户可以用<a href="https://sail.dev/docs/concepts/environment-editing/" target="_blank" rel="noopener">integrated editing</a>来代替。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-14-Sail命令之run</title>
      <link href="/2019/08/19/SailDocument-14-run/"/>
      <url>/2019/08/19/SailDocument-14-run/</url>
      
        <content type="html"><![CDATA[<h1 id="14-Sail命令之run"><a href="#14-Sail命令之run" class="headerlink" title="14-Sail命令之run"></a>14-Sail命令之run</h1><pre><code>Usage: sail run [flags] &lt;repo&gt;# 运行一个项目容器# 如果这个项目还没有创建或者没有运行，那么就会创建这个项目，并且会打开一个新的编辑器。如果这个项目已经启动了，那就不会再启动一个新的容器了，但是这个容器会重新启动并打开一个新的编辑器。# 如果没有提供模式和主机地址，Sail会通过SSH访问github，要修改的话，有好几种方法：1. Specify a host. See examples section2. Specify a schema and host. See examples section3. Edit the config to provide your preferred defaults.Examples:    Use default host and schema(模式) (github.com over SSH, editable in config)    - sail run cdr/code-server    #强制通过ssh访问Github仓库（假设默认使用git用户）    - sail run ssh://github.com/cdr/sshcode    - sail run --ssh github.com/cdr/sshcode    # 自定义一个ssh服务地址    - sail run ssh://colin@git.colin.com/super/secret-repo    - sail run --ssh colin@git.colin.com/super/secret-repo    # 强制使用HTTPS访问Gitlab仓库    - sail run https://gitlab.com/inkscape/inkscape    - sail run --https gitlab.com/inkscape/inkscape# 注意:# 如果是使用ssh://, http://, or https://,你必须声明主机地址# 这样是错误的:    - sail run ssh://cdr/code-server# 您应该添加flags参数来避免使用主机地址.# 这是正确的:    - sail run --ssh cdr/code-serversail run flags:    --hat    自定义要使用的hat.    --http    Clone repo over HTTP (false)    --https    Clone repo over HTTPS (false)    --image    Custom docker image to use.    --keep    Keep container when it fails to build. (false)    --no-open    Don&#39;t open an editor session (false)    --rm    Delete existing container (false)    --ssh    Clone repo over SSH    (false)    --test-cmd    A command to use in-place of starting code-server for testing purposes.</code></pre><blockquote><p><code>run</code>命令会启动一个容器，并且打开项目的浏览器窗口。</p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>尽可能的使用Chrome浏览器，因为Sail在Chrome中有个<code>--app</code>模式，这个模式下code-server的使用体验就跟本地的VS Code的差不多。如果没有Chrome的话，Sail就会用系统默认的浏览器打开一个网址。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-13-在Sail中访问Docker</title>
      <link href="/2019/08/18/SailDocument-13-AccessingDockerWithinSail/"/>
      <url>/2019/08/18/SailDocument-13-AccessingDockerWithinSail/</url>
      
        <content type="html"><![CDATA[<h1 id="13-在Sail中访问Docker"><a href="#13-在Sail中访问Docker" class="headerlink" title="13-在Sail中访问Docker"></a>13-在Sail中访问Docker</h1><p>在Sail中访问Docker的话，你需要安装docker工具，还要将本地的docker socket用share挂载到Sail环境中。</p><p>为了在项目中添加docker支持，你的项目<code>.sail/Dockerfile</code>配置文件中，需要添加类似下面的配置项：</p><pre><code>FROM codercom/ubuntu-dev:latest# 将本地的docker socket通过share挂载到Sail项目中，你就可以使用dacker客户端访问它了LABEL share.docker_sock &quot;/var/run/docker.sock:/var/run/docker.sock&quot;# 查看在ubuntu中安装docker的文档https://docs.docker.com/install/linux/docker-ce/ubuntu/RUN sudo apt-get update &amp;&amp; sudo apt-get install -y \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-commonRUN curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -RUN sudo apt-key fingerprint 0EBFCD88RUN sudo add-apt-repository \   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable&quot;# 只需要安装docker客户端即可，因为我们使用运行在本地的dockerRUN sudo apt-get install -y docker-ce-cli</code></pre><p>注意：这会将本地的所有容器都暴露在Sail环境中，甚至是Sail环境本身所在的容器，所以千万不要把运行Sail环境的容器删除了。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-12-运行界面应用</title>
      <link href="/2019/08/17/SailDocument-12-RunningGUIApplications/"/>
      <url>/2019/08/17/SailDocument-12-RunningGUIApplications/</url>
      
        <content type="html"><![CDATA[<h1 id="12-运行界面应用"><a href="#12-运行界面应用" class="headerlink" title="12-运行界面应用"></a>12-运行界面应用</h1><p>如果Linux支持x11，Sail可以在上面运行界面应用。</p><p>如果运行Sail的Linux上配置了<code>$DISPLAY</code>环境变量，那么Sail将挂载x11 socket和xauthority文件，并在容器中配置好环境变量，用户就可以在容器中运行带界面的应用了。</p><p>例如，在Sail里运行火狐浏览器：</p><pre><code># 确保您已经安装了火狐浏览器，为了快速的尝试一下，从终端安装即可，但是如果项目依赖了火狐浏览器，那就需要在`.sail/Dockerfile`中配置依赖。$ sudo apt-get install -y firefox# 在新窗口中打开火狐浏览器$ /usr/bin/firefox</code></pre><p>如果您运行出了下面的错误：</p><pre><code>No protocol specifiedUnable to init server: Could not connect: Connection refusedError: cannot open display: :0</code></pre><p>当您尝试启动一个界面应用，您要确保您有权限访问Xserver服务。您可以通过命令<code>xhost si:localuser:${USER}</code>给你的本地用户赋予访问Xserver服务的权限。注意，这个命令的赋权在你重启系统或者重启Xserver后会失效，所以重启之后你需要再执行一遍。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-11-在你的项目中添加Sail</title>
      <link href="/2019/08/16/SailDocument-11-AddSailToYourProject/"/>
      <url>/2019/08/16/SailDocument-11-AddSailToYourProject/</url>
      
        <content type="html"><![CDATA[<h2 id="11-在你的项目中添加Sail"><a href="#11-在你的项目中添加Sail" class="headerlink" title="11-在你的项目中添加Sail"></a>11-在你的项目中添加Sail</h2><p>您可以通过添加一个Dockerfile来增加你的项目对Sail的支持。Dockerfile必须在你项目的根目录下的<code>.sail/Dockerfile</code>。</p><p>文件创建之后，你可以修改<code>FROM</code>子句，添加Sail支持的镜像。支持的镜像托管在codercom的docker hub中，命名格式为<code>codercom/ubuntu-dev*</code>。</p><h3 id="选择基础镜像"><a href="#选择基础镜像" class="headerlink" title="选择基础镜像"></a>选择基础镜像</h3><p>目前，这些镜像都是基于ubuntu 18.10构建的，其中一些包含了安装好和配置好的编程语言环境，你可以基于这些编程语言环境来构建自己的项目环境。</p><p>例如，你有一个python项目，你可能想根据你使用的python版本，把<code>FROM</code>子句改为<code>FROM codercom/ubuntu-dev-python3.7</code> 或者 <code>FROM codercom/ubuntu-dev-python2.7</code>。这可以确保帮您安装和配置好正确的python和pip版本，还有一些常用的python的VS Code插件。</p><h3 id="自定义项目环境"><a href="#自定义项目环境" class="headerlink" title="自定义项目环境"></a>自定义项目环境</h3><p>选好了基础环境之后，其他的项目依赖和配置都可以通过Dockerfile语法和Sail标签来配置。</p><p>例如：</p><pre><code># 使用预先定义好的编程语言基础镜像FROM codercom/ubuntu-dev-python3.7:latest# 安装一些监控系统和程序的开发工具RUN sudo apt-get update -y &amp;&amp; sudo apt-get install -y \    dstat \    wireshark# 为python项目安装setuptoolsRUN pip install -U setuptools# 添加需要的环境变量ENV PATH $PATH:/my/additional/bins# 为项目数据添加一个share目录LABEL share.app_cache &quot;~/app/cache:~/app/cache&quot;</code></pre><p>Sail将会使用这个Dockerfile来构建您的开发环境，您可以明确的声明项目的依赖和配置，这样，所有的开发者都可以使用一样的开发环境了。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-10-配置</title>
      <link href="/2019/08/15/SailDocument-10-Configuration/"/>
      <url>/2019/08/15/SailDocument-10-Configuration/</url>
      
        <content type="html"><![CDATA[<h1 id="10-配置"><a href="#10-配置" class="headerlink" title="10-配置"></a>10-配置</h1><p>Sail尽量都将配置放到了项目和hats中，所以它基本上配置很少。但是Sail仍然有一点全局配置，默认放在了</p><pre><code>~/.config/sail/sail.toml</code></pre><p>这是一个默认的配置文件，可以作为参考：</p><pre><code># 如果项目没有提供镜像配置，将会使用default_image配置的镜像作为默认镜像default_image = &quot;codercom/ubuntu-dev&quot;# project_root是项目挂载的基础目录。项目将会以&quot;&lt;root&gt;/&lt;org&gt;/&lt;repo.&quot;格式保存在目录中project_root = &quot;~/Projects&quot;# default_hat是配置一个hat的默认配置文件，它会自动执行。# default_hat = &quot;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-09-环境编辑</title>
      <link href="/2019/08/14/SailDocument-09-Environment-Editing/"/>
      <url>/2019/08/14/SailDocument-09-Environment-Editing/</url>
      
        <content type="html"><![CDATA[<h2 id="09-环境编辑"><a href="#09-环境编辑" class="headerlink" title="09-环境编辑"></a>09-环境编辑</h2><p>VS Code在编辑Sail开发环境时，开箱即用。</p><ol><li>在你的编辑器中打开<code>.sail/Dockerfile</code></li><li>修改配置</li><li>点击rebuild按钮<br><img src="https://sail.dev/rebuild-button.png" alt="UI"><br>在容器重新构建的过程中，界面是冻结的。</li></ol><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li>重新构建的快捷键是:Ctrl+Shift+r </li><li>将Dockerfile的变化部分移动到文件底部，不变的部分会有缓存。？？？？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-08-Docker</title>
      <link href="/2019/08/13/SailDocument-08-Docker/"/>
      <url>/2019/08/13/SailDocument-08-Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="08-Docker"><a href="#08-Docker" class="headerlink" title="08-Docker"></a>08-Docker</h1><p>Sail可以被认为是Docker工具链的包装器，它专门用来管理开发环境。<br>它以元数据和标签的形式将大部分状态存储在Docker守护程序中。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>Sail鼓励以易于共享和迭代的方式明确描述您的开发环境的工作流程。<br>如果要对环境进行更改，就应修改hat或项目的Dockerfile。</p><h2 id="定义项目开发环境"><a href="#定义项目开发环境" class="headerlink" title="定义项目开发环境"></a>定义项目开发环境</h2><p>项目可以通过一个<code>.sail/Dockerfile</code>配置文件来定义开发环境，如果在项目中没有找到<code>.sail/Dockerfile</code>，那么就会使用<code>codercom/ubuntu-dev</code>作为基础镜像。</p><p>在自定义项目环境时，dev容器必须是<code>codercom/ubuntu-dev</code>的祖先才能拥有正确的依赖关系设置。</p><p>构建项目的镜像时，将会把项目的根目录作为构建的根目录，实际上是调用了下面的构建命 令：</p><pre><code> docker build -f $project_root/&lt;org&gt;/&lt;repo&gt;/.sail/Dockerfile $project_root/&lt;org&gt;/&lt;repo&gt;</code></pre><h2 id="容器权限"><a href="#容器权限" class="headerlink" title="容器权限"></a>容器权限</h2><p>本地的当前用户将映射到开发环境中名为user的用户。这意味着容器内的文件跟您在本地环境具有相同的权限。<br>Sail在容器内使用<code>user</code>账户，不是<code>root</code>，因为:</p><ul><li>root账户对许多工具不太友好。</li><li>大多数开发人员习惯于非root用户和使用sudo</li></ul><h2 id="容器的命名"><a href="#容器的命名" class="headerlink" title="容器的命名"></a>容器的命名</h2><p>在Docker中容器被命名为<code>&lt;org&gt;_&lt;project&gt;</code>格式，但是在Sail中是<code>&lt;org&gt;/project</code></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>为了尽量让您有本地开发的环境体验，Sail尽可能使用docker宿主机网络。这就是说，如果你在Sail中的网络服务绑定到了8080端口，那么在你本地的浏览器中可以直接访问<code>127.0.0.1:8080</code>。</p><p>在Mac上，Docker不支持使用宿主机网络，所以Sail在Mac上的宿主网络不好使。Sail计划在未来的版本中解决这个问题。</p><h2 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h2><p>在<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Dockerfile最佳实践</a>，你可以参考如何正确构建和编写项目以及Dockerfiles。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-07-标签</title>
      <link href="/2019/08/12/SailDocument-07-Labels/"/>
      <url>/2019/08/12/SailDocument-07-Labels/</url>
      
        <content type="html"><![CDATA[<h1 id="07-标签"><a href="#07-标签" class="headerlink" title="07-标签"></a>07-标签</h1><p>Sail广泛的使用Docker标签来维护状态，并允许用户完全配置他们的项目环境。</p><h2 id="配置标签"><a href="#配置标签" class="headerlink" title="配置标签"></a>配置标签</h2><p>项目的根标签<br>如《项目》中所述，您可以使用<code>project_root</code>标签来指定项目根的挂载目录。Sail默认的挂载目录是容器中的<code>~/&lt;repo&gt;</code>。</p><p>例如：</p><pre><code>LABEL project_root &quot;~/go/src/&quot;</code></pre><p>将会挂载本地的<code>$project_root/&lt;org&gt;/&lt;repo&gt;</code>目录到容器中的<code>~/go/src/&lt;repo&gt;</code>。</p><h3 id="Share-标签"><a href="#Share-标签" class="headerlink" title="Share 标签"></a>Share 标签</h3><p>Sail的share是一个你想跟容器分享的本地目录。项目或者是hat的Dockerfile中的share，将会把你指定的目录挂载到容器中的相应位置。</p><p>项目或者hat的Dockerfile可以使用如下形式的标签配置命令:</p><pre><code>share.&lt;share_name&gt;=&quot;host_path:guest_path&quot;.</code></pre><p>例如：如果你想跟容器共享本地的go模块缓存，你可以在项目或者hat的Dockerfile中添加如下命令：</p><pre><code>LABEL share.go_mod=&quot;~/go/pkg/mod:~/go/pkg/mod&quot;</code></pre><h4 id="以下情况推荐使用share："><a href="#以下情况推荐使用share：" class="headerlink" title="以下情况推荐使用share："></a>以下情况推荐使用share：</h4><ul><li>系统级的缓存<ul><li>go模块缓存</li><li>Yarn 缓存</li></ul></li><li>用户的个性化配置<ul><li>VS Code配置</li><li>SSH密钥</li><li>gitconfig</li></ul></li><li>工作数据<ul><li>项目文件</li><li>数据分析结果<br>需要注意的是：share会破坏开发环境的可重复性和一致性。小心一些比较坑的share，例如<code>~:~</code>。</li></ul></li></ul><h2 id="State-标签"><a href="#State-标签" class="headerlink" title="State 标签"></a>State 标签</h2><p>Sail使用以<code>com.coder.sail</code>开头的Docker标签来管理CLI可能需要的状态。 这些标签仅在Sail CLI中需要，对用户配置无用。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-06-Hats</title>
      <link href="/2019/08/11/SailDocument-06-Hats/"/>
      <url>/2019/08/11/SailDocument-06-Hats/</url>
      
        <content type="html"><![CDATA[<h1 id="06-Hats"><a href="#06-Hats" class="headerlink" title="06-Hats"></a>06-Hats</h1><p><strong><em>hat</em></strong> 是一个包含Dockerfile文件的构建目录，它可以让您使用个性化配置来拓展您的项目环境。hat可以将您自己的工具，配置和工作流加入到您的Sail项目中。</p><p>为了让Sail扩展项目的开发环境，hat的Dockerfile中的<code>FROM</code>子句被项目仓库中的<code>FROM</code>替换。</p><p>例如：</p><pre><code>FROM ubuntuRUN sudo apt install fishRUN chsh user -s $(which fish)</code></pre><p>这是一个hat配置，它会安装fish，并将其配置为默认的shell，不管仓库中的<code>FROM</code>镜像中使用的是什么shell。</p><p>在Sail构建您的开发环境的时候，<code>FROM ubuntu</code>将会被<code>FROM &lt;repo_image&gt;</code>替换。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-05-项目所需的插件</title>
      <link href="/2019/08/10/SailDocument-05-Project-defined-Extensions/"/>
      <url>/2019/08/10/SailDocument-05-Project-defined-Extensions/</url>
      
        <content type="html"><![CDATA[<h1 id="05-项目所需的插件"><a href="#05-项目所需的插件" class="headerlink" title="05-项目所需的插件"></a>05-项目所需的插件</h1><p>通过Dockerfile来安装VS Code插件是超级简单的。<br>在Dockerfile中，调用<code>installext &lt;extension ID&gt;</code>即可。</p><blockquote><p>提示：在插件市场的详细页面可以找到插件的id<br><img src="https://sail.dev/extension-id.png" alt="vscode"></p></blockquote><p>例如：</p><pre><code>FROM codercom/ubuntu-dev:latestRUN installext vscodevim.vim</code></pre><p>但是<code>installext</code>命令只在<code>ubuntu-dev</code> or <code>ubuntu-dev-*</code>镜像中是可用的。</p><h2 id="其实"><a href="#其实" class="headerlink" title="其实"></a>其实</h2><p><code>code-server</code>的两个拓展目录是:</p><ul><li><code>~/.vscode/extensions</code>这个目录包含环境中特需的插件</li><li><code>~/.vscode/host-extensions</code>这个目录挂载的是你本地主机中<code>~/.vscode/extensions</code>目录。</li></ul><p>这就确保了，项目既可以使用特需的插件，同时用户也可以继续使用你本地的VS Code插件。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-04-项目</title>
      <link href="/2019/08/09/SailDocument-04-Projects/"/>
      <url>/2019/08/09/SailDocument-04-Projects/</url>
      
        <content type="html"><![CDATA[<h1 id="04-项目"><a href="#04-项目" class="headerlink" title="04-项目"></a>04-项目</h1><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>Sail的核心概念之一是project。每个Sail项目就像是独自占有一个机器，这个机器上只有该项目的依赖和配置。每个Sail项目的开发环境都事先被项目所有者配置好了，因此，你可以更快速的开始贡献代码。</p><p>就像是项目的核心开发给您配置了一个全新的Linux机器一样，他们给你安装好了编程语言和依赖，项目所需的配置也帮您设置好。VSCode也帮您安装了，并且需要的VSCode插件也有。源代码也clone下来了。so，你可以立刻愉快的贡献代码了。</p><p>一个Sail项目就是一个已经配置好的干净的开发环境。除此之外还有一个好处，这个开发环境可以随时丢弃不用，你完全可以重新创建一个一样的环境。</p><h2 id="依赖和配置"><a href="#依赖和配置" class="headerlink" title="依赖和配置"></a>依赖和配置</h2><p>您需要在源码仓库的根目录下创建一个<code>.sail/Dockerfile</code>文件，来明确项目需要哪些依赖。Sail会根据您的配置文件创建一个容器，然后在容器中运行您的开发环境。</p><p>如果一个项目没有<code>.sail/Dockerfile</code>文件，Sail会尝试推断项目使用的语言，如果能推断出项目的语言，就会从<a href="https://hub.docker.com/r/codercom" target="_blank" rel="noopener">codercom docker hub</a>中拉取该语言的Docker基础镜像。如果无法推断出项目语言，或者镜像库中没有该语言的基础镜像，那么<br>就使用<a href="https://hub.docker.com/r/codercom/ubuntu-dev" target="_blank" rel="noopener">codercom/ubuntu-dev</a>镜像作为项目的环境来运行该项目。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>由于容器中的文件系统是临时的，Sail会把clone下来的项目仓库放在本地主机中Sail的<code>$project_root</code>下，并把它挂载到容器中。<br>因为项目是挂载到容器中的，所以删除容器不会删除项目文件，同时您可以随意操作容器外部的项目文件。</p><h3 id="本地主机"><a href="#本地主机" class="headerlink" title="本地主机"></a>本地主机</h3><p><code>$project_root</code>是一个环境变量，配置在Sail的全局配置文件中，配置文件默认放在<code>~/Projects</code>。项目通常放在<code>$project_root</code>下，目录结构如下：</p><pre><code>$project_root/&lt;org&gt;/&lt;repo&gt;</code></pre><p>例如，你要使用一个新的Sail环境，</p><pre><code>sail run cdr/sail</code></pre><p>它将被clone到<code>$project_root/cdr/sail</code>。</p><h3 id="容器内"><a href="#容器内" class="headerlink" title="容器内"></a>容器内</h3><p>默认的，项目会被挂载到容器的<code>~/&lt;repo&gt;</code>下。为了支持一些特殊的语言，比如Go，挂载目录是可以通过项目下配置文件<code>.sail/Dockerfile</code>的<code>project_root</code>标签配置的。<br>例如:</p><pre><code>LABEL project_root &quot;~/go/src/&quot;</code></pre><p>这将会把本地主机的<code>$project_root/&lt;org&gt;/&lt;repo&gt;</code>目录挂载到容器的<code>~/go/src/&lt;repo&gt;</code>目录下。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>项目的配置是通过<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile</a>的命令来完成的。</p><p>例如，如果您的项目将autotools作为依赖项，你可以通过<code>.sail/Dockerfile</code>配置来安装到环境中，如下：</p><pre><code>FROM codercom/ubuntu-dev:latestRUN apt-get update &amp;&amp; apt-get install -y \    autoconf \    automake \    libtool</code></pre><p>为了明确像挂载目录等等配置，Sail拓展了Dockerfile语法，我们将在《标签》中详细介绍这些内容。</p><p>作为一个开发者，你可以想在项目中引入自己的配置和工具。你可以通过hat Dockerfile轻松的拓展项目的开发环境<br>。</p><h2 id="支持的版本管理系统"><a href="#支持的版本管理系统" class="headerlink" title="支持的版本管理系统"></a>支持的版本管理系统</h2><p>当前只支持git</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-03-浏览器插件</title>
      <link href="/2019/08/08/SailDocument-03-BrowserExtension/"/>
      <url>/2019/08/08/SailDocument-03-BrowserExtension/</url>
      
        <content type="html"><![CDATA[<h1 id="03-浏览器插件"><a href="#03-浏览器插件" class="headerlink" title="03-浏览器插件"></a>03-浏览器插件</h1><h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><p>Sail的浏览器插件可以让您在Github或者Gitlab中，只需要点击一下就可以打开项目了。</p><video width="751" height="452" src="https://sail.dev/github-open.mp4" controls="controls"><br>Your browser does not support the video tag.<br></video><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>您可以使用命令<code>sail install-for-chrome-ext</code>来安装Chrome插件manifest.json</li><li>您也可以从<a href="https://chrome.google.com/webstore/detail/sail/deeepphleikpinikcbjplcgojfhkcmna" target="_blank" rel="noopener">Chrome Marketplace</a>安装</li></ol>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail中文文档:一个开发环境快速部署工具-02-安装</title>
      <link href="/2019/08/07/SailDocument-02-Installation/"/>
      <url>/2019/08/07/SailDocument-02-Installation/</url>
      
        <content type="html"><![CDATA[<h1 id="02-安装"><a href="#02-安装" class="headerlink" title="02-安装"></a>02-安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h3><p>当前的Sail只支持Linux和MacOS，Windows将在未来的版本中得到支持。</p><h3 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h3><p>在使用Sail之前，必须安装几个依赖的组件：</p><ol><li>Docker</li><li>Git</li><li>Chrome 或 Chromium - 这不是必需的，但是强烈推荐您使用code-server。如果没有安装Chrome，那么Sail就会使用默认的浏览器。</li></ol><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>为了简单、安全和快速起见，下面的命令将会在您的系统中安装最新的Sail到<code>/usr/local/bin</code>中。同时您需要将<code>/usr/local/bin</code>添加到<code>$PATH</code>环境变量中。</p><pre><code>curl https://sail.dev/install.sh | bash</code></pre><h4 id="稳定版的发布"><a href="#稳定版的发布" class="headerlink" title="稳定版的发布"></a>稳定版的发布</h4><p>您也可以自己从github的releases页面下载，将二进制文件放在您想安装的位置。</p><h4 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h4><p>对高级用户来说，您可以从源码安装。<br>您需要在您的机器上安装和配置好go编程语言，并在您的PATH中添加<code>$ GOPATH / bin</code>。</p><p>Sail使用go模块来构建项目，因此将其安装到系统的最简单方法是将其<code>git clone</code>到GOPATH之外的目录中</p><pre><code>mkdir $HOME/srccd $HOME/srcgit clone https://github.com/cdr/sail.gitcd sailgo install</code></pre><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>您可以使用命令<code>sail --help</code>来验证Sail是否已经安装好。</p><h3 id="浏览插件"><a href="#浏览插件" class="headerlink" title="浏览插件"></a>浏览插件</h3><p>为了在使用Sail时获得最佳体验，我们推荐您安装浏览器插件</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>您只需要按照上面的方法，重新安装Sail即可。</p>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sail:一个开发环境快速部署工具-01-简介</title>
      <link href="/2019/08/06/SailDocument-01-Introduction/"/>
      <url>/2019/08/06/SailDocument-01-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Sail-一个开发环境快速部署工具-01-简介"><a href="#Sail-一个开发环境快速部署工具-01-简介" class="headerlink" title="Sail:一个开发环境快速部署工具-01-简介"></a>Sail:一个开发环境快速部署工具-01-简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是Sail"><a href="#什么是Sail" class="headerlink" title="什么是Sail?"></a>什么是Sail?</h3><p>Sail是一个用来管理docker化的开发环境的CLI工具。它使用docker工具链和<a href="https://github.com/cdr/code-server" target="_blank" rel="noopener">code-server</a>来创建预配置，不可变和源代码控制的开发环境。</p><blockquote><p><strong>译注</strong>：Sail是一个开发环境快速部署工具，它只需要一个命令，就可以快速在Docker中部署出项目的开发环境，并且打开VS Code编辑器，让你快速的可以贡献代码。开发人员不需要再关心项目的依赖和配置，这些Sail都会帮你搞定。<br>一些示例项目:<br><a href="https://github.com/cdr/sail" target="_blank" rel="noopener">https://github.com/cdr/sail</a><br><a href="https://github.com/linux-china/sail-demo" target="_blank" rel="noopener">https://github.com/linux-china/sail-demo</a></p></blockquote><blockquote><p>Sail主页<a href="https://sail.dev/" target="_blank" rel="noopener">Sail</a></p></blockquote><h3 id="为什么使用Sail？"><a href="#为什么使用Sail？" class="headerlink" title="为什么使用Sail？"></a>为什么使用Sail？</h3><p>Sail 是一种全新的开发方式，使用Sail的主要优势如下:</p><ol><li><p>源代码控制 - 开发环境的所有项目依赖和配置都明确的配置在<code>.sail/Dockerfile</code>文件中。</p></li><li><p>环境不可变 - 项目是运行在<code>.sail/Dockerfile</code>配置文件创建的docker容器中，所以，所有的开发者的基础开发环境都是一样。如果你的开发环境因为某种原因乱套了，只需要删除它，然后重新创建一个就可以了。</p></li><li><p>快速的贡献代码 - 使用Sail配置的项目可以很容易的让开发者参与进来，他们不用再操心应该怎么配置项目的开发环境，需要哪些依赖等等。</p></li><li><p>使用你自己的配置文件(dotfiles) - 使用<a href="https://sail.dev/docs/concepts/hats/" target="_blank" rel="noopener">hat</a>，你可以在任何项目中添加自己的环境配置，这样，你可以用你自己喜欢的shell或者vim配置。</p></li><li><p>没有本地垃圾困扰 - 你可以轻松的尝试一些新项目，不必担心项目的依赖会给你本地系统带来垃圾，Sail项目的所有依赖都包含在docker镜像中，这也可以解决你的项目依赖不兼容的问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Sail </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sail </tag>
            
            <tag> 开发环境 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 中文文档 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 快速 </tag>
            
            <tag> code-server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hikari:Apparent connection leak detected连接泄露分析</title>
      <link href="/2019/05/28/hikari-leak/"/>
      <url>/2019/05/28/hikari-leak/</url>
      
        <content type="html"><![CDATA[<p>部分报错日志如下:</p><pre><code>16-05-2019 13:25:46.494 [HikariPool-1 housekeeper] WARN  com.zaxxer.hikari.pool.ProxyLeakTask.run - Connection leak detection triggered for com.mysql.jdbc.JDBC4Connection@7c3beffb, stack trace followsjava.lang.Exception: Apparent connection leak detected    at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:111)    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:77)    at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:84)    at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:70)    at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:336)    at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84)    at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62)    at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324)    at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)    at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)    at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83)    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148)    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141)    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:77)    at sun.reflect.GeneratedMethodAccessor148.invoke(Unknown Source)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:434)    at com.sun.proxy.$Proxy107.selectOne(Unknown Source)    at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:167)</code></pre><p>日志显示，检测到了连接泄露<br>Hikari配置如下：</p><pre><code>hikari:      maximum-pool-size: 100      minimum-idle: 0      leak-detection-threshold: 180000      connection-timeout: 180000      validation-timeout: 180000      idle-timeout: 180000</code></pre><p>leak-detection-threshold:用来设置连接被占用的超时时间，单位为毫秒，默认为0，表示禁用连接泄露检测。<br>connection-timeout:从连接池获取连接的超时时间。</p><p>分析源代码发现，该错误的原因是从连接池获取连接超时，触发了连接泄露检测。<br>此处spring调用了doGetConnection从hikari中获取连接，<br>在org.springframework.jdbc.datasource.DataSourceUtils#doGetConnection中，<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/HDMj2V.jpg" alt="hikari-1.jpg"><br>我们看看hikari中的实现，，进入该方法继续看，<br>com.zaxxer.hikari.HikariDataSource#getConnection()<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/ATRITV.jpg" alt="hikari-2.jpg"><br>在com.zaxxer.hikari.pool.HikariPool#getConnection(long)中，<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/7vMFW0.jpg" alt="hikari-3.jpg"><br>com.zaxxer.hikari.pool.ProxyLeakTask#ProxyLeakTask(com.zaxxer.hikari.pool.ProxyLeakTask, com.zaxxer.hikari.pool.PoolEntry)中<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/OG3tGc.jpg" alt="hikari-4.jpg"><br>这个地方是真正的获取连接的实现了，<br>分析上面的代码会发现，在获取Connection的时候，创建了一个ProxyLeakTask，这个task是一个定时任务，在leakDetectionThreshold毫秒后调用run()方法抛出Apparent connection leak detected异常。<br><img src="https://gitee.com/yifeng0898/picbed/raw/master/uPic/2020/04/01/S4ah4I.jpg" alt="hikari-5.jpg"><br>也就是说，获取到连接之后使用之前的时间+使用连接的时间+使用之后还回连接之前的时间，超出了leakDetectionThreshold毫秒，就抛出检测到连接泄露的异常。结合我们的业务发现，此处确实是使用连接的时间超出了leakDetectionThreshold毫秒，是因为执行了慢 sql，同时慢 sql 耗尽了连接池的连接，导致新线程获取连接超时，又导致了获取连接超时的报错。</p>]]></content>
      
      
      <categories>
          
          <category> 问题排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hikari </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
